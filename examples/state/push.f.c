/* Generated by re2c */
#line 1 "state/push.f.re"
#include <assert.h>
#include <stdio.h>
#include <string.h>

#define SIZE 4096

typedef struct {
    char buf[SIZE + 1], *lim, *cur, *tok, yych;
    unsigned yyaccept;
    int state;
} Input;

static void init(Input *in)
{
    in->cur = in->tok = in->lim = in->buf + SIZE;
    in->lim[0] = 0; // append sentinel symbol
    in->yych = 0;
    in->yyaccept = 0;
    in->state = -1;
}

static int fill(Input *in)
{
    const size_t shift = in->tok - in->buf;
    const size_t free = SIZE - (in->lim - in->tok);

    if (free < 1) return 1; // not enough space in buffer

    memmove(in->buf, in->tok, SIZE - shift);
    in->lim -= shift;
    in->cur -= shift;
    in->tok -= shift;

    const size_t read = fread(in->lim, 1, free, stdin);
    in->lim += read;
    in->lim[0] = 0; // append sentinel symbol

    return 0;
}

typedef enum {OK, SYNTAX_ERROR, UNEXPECTED_EOF, NEED_MORE_INPUT} Status;

#define YYGETSTATE()  in->state
#define YYSETSTATE(s) in->state = s
#define YYFILL()      return NEED_MORE_INPUT
static Status lex(Input *in, unsigned *words)
{
    switch (YYGETSTATE()) {
default:
	goto yy0;
case 0:
	if (in->lim <= in->cur) goto yyeofrule1;
	goto yyFillLabel0;
case 1:
	if (in->lim <= in->cur) goto yy7;
	goto yyFillLabel1;
case 2:
	if (in->lim <= in->cur) goto yy10;
	goto yyFillLabel2;
case 3:
	if (in->lim <= in->cur) goto yy10;
	goto yyFillLabel3;
case 4:
	if (in->lim <= in->cur) goto yy10;
	goto yyFillLabel4;
case 5:
	if (in->lim <= in->cur) goto yy10;
	goto yyFillLabel5;
case 6:
	if (in->lim <= in->cur) goto yy15;
	goto yyFillLabel6;
}

loop:
    in->tok = in->cur;
    
#line 80 "state/push.f.c"

yy0:
yyFillLabel0:
	in->yych = *in->cur;
	switch (in->yych) {
	case '\n':
	case ' ':	goto yy5;
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy8;
	case 's':	goto yy11;
	default:
		if (in->lim <= in->cur) {
			YYSETSTATE(0);
			YYFILL();
		}
		goto yy3;
	}
yy3:
	++in->cur;
#line 58 "state/push.f.re"
	{ return SYNTAX_ERROR; }
#line 151 "state/push.f.c"
yy5:
	++in->cur;
yyFillLabel1:
	in->yych = *in->cur;
	switch (in->yych) {
	case '\n':
	case ' ':	goto yy5;
	default:
		if (in->lim <= in->cur) {
			YYSETSTATE(1);
			YYFILL();
		}
		goto yy7;
	}
yy7:
#line 61 "state/push.f.re"
	{ goto loop; }
#line 169 "state/push.f.c"
yy8:
	++in->cur;
yyFillLabel2:
	in->yych = *in->cur;
yy9:
	switch (in->yych) {
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy8;
	default:
		if (in->lim <= in->cur) {
			YYSETSTATE(2);
			YYFILL();
		}
		goto yy10;
	}
yy10:
#line 62 "state/push.f.re"
	{ *words = *words + 1; goto loop; }
#line 238 "state/push.f.c"
yy11:
	++in->cur;
yyFillLabel3:
	in->yych = *in->cur;
	switch (in->yych) {
	case 0x00:
		if (in->lim <= in->cur) {
			YYSETSTATE(3);
			YYFILL();
		}
		goto yy10;
	case 't':	goto yy12;
	default:	goto yy9;
	}
yy12:
	++in->cur;
yyFillLabel4:
	in->yych = *in->cur;
	switch (in->yych) {
	case 0x00:
		if (in->lim <= in->cur) {
			YYSETSTATE(4);
			YYFILL();
		}
		goto yy10;
	case 'o':	goto yy13;
	default:	goto yy9;
	}
yy13:
	++in->cur;
yyFillLabel5:
	in->yych = *in->cur;
	switch (in->yych) {
	case 0x00:
		if (in->lim <= in->cur) {
			YYSETSTATE(5);
			YYFILL();
		}
		goto yy10;
	case 'p':	goto yy14;
	default:	goto yy9;
	}
yy14:
	++in->cur;
yyFillLabel6:
	in->yych = *in->cur;
	switch (in->yych) {
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy8;
	default:
		if (in->lim <= in->cur) {
			YYSETSTATE(6);
			YYFILL();
		}
		goto yy15;
	}
yy15:
#line 60 "state/push.f.re"
	{ return OK; }
#line 348 "state/push.f.c"
yyeofrule1:
#line 59 "state/push.f.re"
	{ return UNEXPECTED_EOF; }
#line 352 "state/push.f.c"
#line 63 "state/push.f.re"

}

int main()
{
    unsigned words = 0;
    Input in;
    init(&in);

    for (;;) {
        const Status st = lex(&in, &words);
        if (st == OK) {
            printf("word count: %u\n", words);
            break;
        }
        else if (st == SYNTAX_ERROR) {
            printf("error: unexpected symbol\n");
            return 1;
        }
        else if (st == UNEXPECTED_EOF) {
            printf("error: unexpected end of input\n");
            return 2;
        }
        else if (fill(&in) != 0) {
            printf("error: not enough space in buffer\n");
            return 3;
        }
    }

    return 0;
}