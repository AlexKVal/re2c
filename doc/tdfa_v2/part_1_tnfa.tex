\documentclass[AMA,STIX1COL]{WileyNJD-v2}

\articletype{Research Article}

\received{26 April 2016}
\revised{6 June 2016}
\accepted{6 June 2016}

\raggedbottom

%\usepackage{booktabs}

\let\procedure\relax
\let\endprocedure\relax

%\usepackage[ruled]{algorithm2e} % For algorithms

\usepackage[noline, noend, nofillcomment, linesnumbered]{algorithm2e}
%\usepackage[noline, noend, nofillcomment]{algorithm2e}
%\usepackage[noline, noend, nofillcomment, linesnumbered]{algorithm2e}
%    \setlength{\algomargin}{0em}

\usepackage{setspace}

\SetArgSty{textnormal}

% comments in the pseudocode
% note: on my system \texttt is broken with \small font size (too small)
\newcommand\Xcommentfont[1]{\selectfont\textnormal{#1}}
%\newcommand\Xcommentfont[1]{\fontsize{9pt}{0pt}\selectfont\texttt{#1}}
\SetCommentSty{Xcommentfont}
\SetNoFillComment

\SetNlSty{textnormal}{}{}

\renewcommand{\algorithmcfname}{ALGORITHM}
%\SetAlFnt{\small}
%\SetAlCapFnt{\small}
%\SetAlCapNameFnt{\small}
%\SetAlCapHSkip{0pt}
%\IncMargin{-\parindent}

\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{accents}
\usepackage{mathtools}
\usepackage{graphicx}
\usepackage{enumitem}
\usepackage[justification=centering]{caption}
\usepackage{url}
\usepackage[section]{placeins}

\newcommand{\Xl}{\langle}
\newcommand{\Xr}{\rangle}
\newcommand{\Xm}{\langle\!\rangle}
\newcommand{\Xset}{\!\leftarrow\!}
\newcommand{\Xund}{\rule{.4em}{.4pt}}
\newcommand{\Xlb}{[\![}
\newcommand{\Xrb}{]\!]}
\newcommand{\Xmap}{\!\mapsto\!}
\newcommand{\XB}{\mathcal{B}}
\newcommand{\XD}{\mathcal{D}}
\newcommand{\XE}{\mathcal{E}}
\newcommand{\XF}{\mathcal{F}}
\newcommand{\XI}{\mathcal{I}}
\newcommand{\XPT}{\XP\!\XT}
\newcommand{\XIT}{\XI\!\XT}
\newcommand{\XIR}{\XI\!\XR}
\newcommand{\XL}{\mathcal{L}}
\newcommand{\XN}{\mathcal{N}}
\newcommand{\XM}{\mathcal{M}}
\newcommand{\XO}{\mathcal{O}}
\newcommand{\XP}{\mathcal{P}}
\newcommand{\XR}{\mathcal{R}}
\newcommand{\XS}{\mathcal{S}}
\newcommand{\XT}{\mathcal{T}}
\newcommand{\XX}{\mathcal{X}}
\newcommand{\YB}{\mathbb{B}}
\newcommand{\YC}{\mathbb{C}}
\newcommand{\YF}{\mathbb{F}}
\newcommand{\YN}{\mathbb{N}}
\newcommand{\YT}{\mathbb{T}}
\newcommand{\YQ}{\mathbb{Q}}
\newcommand{\YZ}{\mathbb{Z}}
\newcommand{\PT}{PT}
\newcommand{\PE}{P\!E}
\newcommand{\IPT}{I\!PT}
\newcommand{\IRE}{I\!RE}

\newcommand{\Xstirling}[2]{\genfrac{\{}{\}}{0pt}{}{#1}{#2}}
\newcommand*{\Xbar}[1]{\overline{#1\vphantom{\bar{#1}}}}
\newcommand{\pnorm}[2]{\|{#1}\|^{Pos}_{#2}}
\newcommand{\snorm}[2]{\|{#1}\|^{Sub}_{#2}}

\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

\setlist{nosep}
%\setlength{\parskip}{0.5em}

\newenvironment{Xfig}
    {\par\medskip\noindent\minipage{\linewidth}\begin{center}}
    {\end{center}\endminipage\par\medskip}
\newenvironment{Xtab}
    {\par\medskip\noindent\minipage{\linewidth}\begin{center}}
    {\end{center}\endminipage\par\medskip}

\setlength{\parindent}{0pt}
\setlength{\belowcaptionskip}{-1em}

%\theoremstyle{definition}
\newtheorem{Xdef}{Definition}
\newtheorem{XThe}{Theorem}
\newtheorem{XLem}{Lemma}
\newtheorem{Xobs}{Observation}


\begin{document}

\title{Practical POSIX Submatch Extraction on NFA}

\author[1]{Angelo Borsotti}
\author[2]{Ulya Trofimovich}

\address[1]{\email{angelo.borsotti@mail.polimi.it}}
\address[2]{\email{skvadrik@gmail.com}}

\abstract[Summary]{
We give an algorithm for regular expression parsing and submatch extraction with POSIX longest-match semantics.
Our algorithm is based on Okui-Suzuki disambiguation procedure
with a number of non-trivial improvements.
Worst-case time complexity is $O(n \, m^2 \, t)$
and memory requirement is $O(m^2)$,
where $n$ is the length of input, $m$ is the size of regular expression
and $t$ is the number of capturing groups plus enclosing subexpressions.
We perform comparative study of other algorithms
and show that our algorithm outperforms other POSIX matching algorithms,
and stays reasonably close to leftmost greedy matching (a couple of times slower on average).
We also show that backward matching algorithm proposed by Cox is incorrect.
}

\keywords{Regular Expressions, Parsing, Submatch Extraction, Finite-State Automata, POSIX}

%\jnlcitation{\cname{
%\author{U. Trofimovich},
%(\cyear{2017}),
%\ctitle{Fast Submatch Extraction in Lexer Generators},
%\cjournal{Q.J.R. Meteorol. Soc.},
%\cvol{2017;00:1--6}.}

\maketitle

\section{Introduction}

The difficulty of POSIX longest-match semantics is caused by the fact
that we cannot predict correct match results in advance, at the point where they diverge.
To see this, consider regular expression \texttt{(a\{2\}|a\{3\}|a\{5\})*} and string \texttt{a...a}.
Submatch on the last iteration varies with the length of input:
it equals \texttt{aaaaa} for $5n$-character string,
\texttt{aa} for strings of length $5n - 3$ and $5n - 1$,
and \texttt{aaa} for strings of length $5n - 2$ and $5n + 1$ ($n \in \YN$).
Variation continues infinitely with a period of five characters.
The period is a property of regular expression;
in our example we can change it by choosing different counter values.
POSIX matching algorithms deal with this difficulty in different ways.
On one side we have generic, but inefficient approaches like exhaustive backtracking and dynamic programming.
On the other side we have algorithms based on deterministic automata [SL13] [Bor15] [Tro17]
that are very efficient at run-time, because all disambiguation is done in advance and built into DFA.
However, DFA construction is not always viable due to its exponential worst-case complexity,
and if viable, it needs to be efficient.
Therefore in this work we concentrate on practical NFA-based algorithms
that can be used directly for matching or serve as a basis for DFA construction.
We give an overview of existing algorithms, including some that are incorrect, but interesting.

\subparagraph{Laurikari, 2001 (incorrect).}

Laurikari based his algorithm on TNFA ---
$\epsilon$-NFA with tagged transitions [Lau01].
Each submatch group is represented with a pair of \emph{tags} (opening and closing).
Disambiguation is based on minimizing the value of opening tags and maximizing tha value of closing tags, where
different tags have priority according to POSIX subexpression hierarchy.
Notably, Laurikari used the idea of topological order to avoid worst-case exponential time of $\epsilon$-closure construction.
His algorithm doesn't track history of iteration subexpressions and gives incorrect result in cases like \texttt{(a|aa)*} and string \texttt{aa}.
Reported computational complexity is $O(n \, m \, c \, t \, log(t))$, where
$n$ is input length,
$m$ is TNFA size,
$c$ is the time for comparing tag values
and $t$ is the number of tags.
Memory requirement is $O(m \, t)$.

\subparagraph{Kuklewicz, 2007.}

Kuklewicz fixed Laurikari algorithm by introducing \emph{orbit} tags for iteration subexpressions.
He gave only an informal description [Kuk07], but the algorithm was later formalized in [Tro17].
It works in the same way as Lauirikari algorithm,
except that comparison of orbit tags is based on their previous history, not just the most recent value.
The clever idea is to avoid recording full history
by compressing histories in a matrix of size $t \times m$, where $m$ is TNFA size and $t$ is the number of tags.
$t$-Th row of the matrix represents ordering of closure states with respect to $t$-th tag
(with possible ties --- different states may have the same order).
Matrix is updated at each step using continuations of tag histories.
The algorithm requires $O(m \, t)$ memory and $O(n \, m \, t \, (m + t \, log(m))$ time, where $n$ is the input length:
$\epsilon$-closure takes $O(m^2 \, t)$ assuming worst-case optimal algorithm,
and matrix update takes $O(m \, log(m) \, t^2)$ because for $t$ tags we need to sort $m$ states with $O(t)$ comparison function.
%Kuklewicz disambiguation is combined with Laurikari determinization [Lau00] in [Tro17].

\subparagraph{Cox, 2009 (incorrect).}

Cox came up with the idea of backward matching,
which is based on the observation that it is easier to maximize submatch on the last iteration than on the first one.
For each submatch group the algorithm tracks two pairs of offsets:
the \emph{active} pair with the most recent offsets (used in disambiguation),
and the \emph{final} pair with offsets on the backwards-first iteration.
The algorithm gives incorrect results under two conditions:
(1) ambiguous matches have equal offsets on some iteration,
and (2) comparison happens too late, when active offsets have already been updated and the difference is erased.
We found that such situations may occur for two reasons.
First, $\epsilon$-closure algorithm may compare ambiguous paths \emph{after} their join point,
when both paths have a common suffix with tagged transitions.
This is the case with Cox prototype implementation [Cox09]; for example, it gives incorrect results for \texttt{(aa|a)*} and string \texttt{aaaaa}.
Most of such failures can be repaired by exploring states in topological order,
but topological order does not exist in the presence of $\epsilon$-loops.
The second reason is bounded repetition: ambiguous paths may not have an intermedite join point at all.
For example, in case of \texttt{(aaaa|aaa|a)\{3,4\}} and string \texttt{aaaaaaaaaa}
we have matches \texttt{(aaaa)(aaaa)(a)(a)} and \texttt{(aaaa)(aaa)(aaa)}
with different number of iterations.
If bounded repetion is modelled by duplicating sub-automata and making the last repetition optional,
then by the time ambiguous paths meet both have active offsets \texttt{(0,4)}.
Despite the flaw, Cox algorithm is interesting: if somehow delayed comparison problem was fixed, it would work.
The algorithm requires $O(m \, t)$ memory and $O(n \, m^2 \, t)$ time
(assuming worst-case optimal closure algorithm),
where $n$ is the input length,
$m$ it the size of regular expression
and $t$ is the number of submatch groups plus enclosing subexpressions.

\subparagraph{Okui and Suzuki, 2013.}

Okui and Suzuki view disambiguation problem from the point of comparison of parse trees [OS13].
Ambiguous trees have the same sequence of leaf symbols, but their branching structure is different.
Each subtree corresponds to a subexpression.
The \emph{norm} of a subtree (the number of leaf symbols in it) equals to submatch length.
Longest match corresponds to a tree in which the norm of each subtree in leftmost pre-order traversal is maximized.
The clever idea of Okui and Suzuki is to relate the norm of subtrees to their \emph{height} (distance from the root).
Namely, if we walk through the leaves of two ambiguous trees, tracking the height of each complete subtree,
then at some step heights will diverge:
subtree with a smaller norm will already be complete, but the one with a greater norm will not.
Height of subtrees is easy to track by attibuting it to parentheses and encoding in automaton transitions.
Okui and Suzuki use PAT --- $\epsilon$-free position automaton with transitions labelled by sequences of parentheses.
Disambiguation is based on comparing parentheses along ambiguous PAT paths.
Similar to Kuklewicz, Okui and Suzuki avoid recording full-length paths
by pre-comparing them at each step and storing comparison results in a pair of matrices indexed by PAT states.
The authors report complexity $O(n(m^2 + c))$, where
$n$ is the input length,
$m$ is the number of occurrences of the most frequent symbol in regular expression
and $c$ is the number of submatch groups and repetition operators.
However, this estimate leaves out the constuction of PAT and precomputation of precedence relation.
Memory requirement is $O(m^2)$.
Okui-Suzuki disambiguation is combined with Berry-Sethi construction in [Bor15] in construction of parsing DFA.

\subparagraph{Sulzmann and Lu, 2013.}

Sulzmann and Lu based their algorithm on Brzozowski derivatives [??]
(correctness proof is given by Ausaf, Dyckhoff and Urban [??]).
The algorithm unfolds a regular expression into a sequence of derivatives
(each derivative is obtained from the previous one by consuming the next input symbol),
and then folds it back into a parse tree
(the tree for the previous derivative is built from the tree for the next derivative by ``injecting'' the corresponding input symbol).
In practice, Sulzmann and Lu fuse backward and forward passes,
which allows to avoid potentially unbounded memory usage on keeping all intermediate derivatives.
The algorithm is unique in that it does not require explicit disambiguation: longest match is obtained by construction.
Time and space complexity is not entirely clear.
In [??] Sulzmann and Lu consider the size of the regular expression as a constant.
In [??] they give more precise estimates: $O(2^m \, t)$ space and $O(n \, log(2^m) \, 2^m \, t^2)$ time,
where $m$ is the size of the regular expression,
$n$ is the length of input
and $t$ the number of submatch groups (the authors do not differentiate between $m$ and $t$).
However, this estimate assumes worst-case $O(2^m)$ derivative size and on-the-fly DFA construction.
The authors also mention a better $O(m^2)$ theoretical bound for derivative size.
If we adopt it and exclude DFA consturuction, we get $O(m^2 \, t)$ memory requirement and $O(n \, m^2 \, t^2)$ time,
which seems reasonably close to other approaches.
\\

Undoubtedly other approaches exist,
but many of them produce incorrect results or require memory proportional to the length of input
(see Glibc implementation for example [??]).
We choose automata-based approach over derivatives for two reasons:
first, we feel that both approaches deserve to be studied and formalized;
and second, in our experience derivative-based implementation was too slow.
Of the two automata-based approaches, Kuklewicz and Okui-Suzuki, the latter appears to be somewhat faster in practice.
However, computationally they are very similar:
both compare partial matches incrementally at each step,
only Kuklewicz considers histories of each tag separately.
Our contributions are as follows:
\\

\begin{itemize}[itemsep=0.5em]

    \item We extend Okui-Suzuki algorithm on the case of partially ordered parse trees.
        The original algorithm considers all subexpressions as submatch groups,
        which means a lot of overhead if only a few groups are needed.

    \item We extend Okui-Suzuki algorithm on the case of bounded repetition.
        This presents some unique challenges (like the one discussed with regard to Cox algorithm).

    \item We combine Okui-Suzuki algorithm with Laurikari TNFA
        and omit the preprocessing step of the original algorithm.
        We do not argue that TNFA is generally faster than PAT,
        but it may be preferable due to its simple construction.

    \item We introduce \emph{negative tags} that allow us to handle
        no-match in the same way as match.
        In particular, this removes the need to fix obsolete offsets that remain from earlier iterations,
        in cases like \texttt{(a(b)?)*} and string \texttt{aba}.

    \item We consider $\epsilon$-closure construction as a shortest-path problem
        and show that TNFA paths together with operations of path comparison and concatenation form a right-distributive semiring.
        This allows us to apply the well-known algorithm by Goldberg-Radzik based on the idea of topological order.
        It has worst-case optimal quadratic complexity in the size of closure,
        and guaranteed linear complexity if the closure has no loops.
        This is an improvement over naive exhaustive depth-first search with backtracking,
        and also an improvement over Laurikari algorithm as shown in [Tro17].

    \item We give a faster algorithm for updating precedence matrix.
        The straightforward algorithm described by Okui-Suzuki involves pairwise comparison of all states in closure
        and takes $O(m^2 \, t)$ time, assuming $m$ states and $O(t)$ comparison function.
        We found a pathological case \texttt{((a?)\{0,1000\})*} where $t \approx m$ and naive algortihm takes cubic time.
        Our algorithm takes $O(m^2)$ time (which is still slow, but a considerable improvement).

    \item We provide an implementation of different algorithms in C++ (except for the one by Sulzmann and Lu)
        and benchmark them against each other and against leftmost greedy matching implemented in RE2.

    \item We give detailed proof of correctness of the extended algorithm.
    \\
\end{itemize}

The rest of this paper is arranged as follows.
In the next section we describe the main idea and the skeleton of the algorithm.
In the following sections we fill in the gaps:
in section [??] we consider different possible outputs of the algorithm,
in section [??] we build $\epsilon$-closure,
in section [??] we construct TNFA.
Finally, section [??] contains benchmarks
and section [??] concludes.

\section{The main idea}\label{secion_main}

Our algorithm is based on four cornerstone concepts:
regular expressions, parse trees, parenthesized expressions and tagged NFA.
The first two are needed to formulate submatch extraction problem
and define POSIX disambiguation semantics in terms of comparison of parse trees.
Parenthesized expressions are linearized representation of parse trees
that allow us to give an equivalent, but more practical definition of comparison.
Finally, automata with tagged transitions are used to encode parentheses
and construct an efficient matching algorithm.
In this section we give the four basic definitions, followed by a sketch of the algorithm.
In later sections we fill in all the details and provide connection between different representations.

    \begin{Xdef}
    \emph{Regular expressions (RE)} over finite alphabet $\Sigma$, denoted $\XR_\Sigma$:
    \begin{enumerate}
        \item
          Empty RE $\epsilon$ and
          unit RE $\alpha$ (where $\alpha \in \Sigma$) are in $\XR_\Sigma$.
        \item If $e_1, e_2 \in \XR_\Sigma$, then
          union $e_1 | e_2$,
          product $e_1 e_2$,
          repetition $e_1^{n, m}$ (where $0 \leq n \leq m \leq \infty$), and
          submatch group $(e_1)$
          are in $\XR_\Sigma$.
    \end{enumerate}
    \end{Xdef}


    \begin{Xdef}
    \emph{Parse trees (PT)} over finite alphabet $\Sigma$, denoted $\XT_\Sigma$:
    \begin{enumerate}
        \item
          Nil tree ${\varnothing}^i$,
          empty tree ${\epsilon}^i$ and
          unit tree ${\alpha}^i$ (where $\alpha \in \Sigma$ and $i \in \YZ$)
          are in $\XT_\Sigma$.
        \item If $t_1, \dots, t_n \in \XT_\Sigma$ (where $n \geq 1$, and $i \in \YZ$), then
          ${T}^i(t_1, \dots, t_n)$
          is in $\XT_\Sigma$.
    \end{enumerate}
    \end{Xdef}


    \begin{Xdef}
    \emph{Parenthesized expressions (PE)} over finite alphabet $\Sigma$, denoted $\XP_\Sigma$:
    \begin{enumerate}
        \item
            Nil expression $\Xm$,
            empty expression $\epsilon$ and
            unit expression $\alpha$ (where $\alpha \in \Sigma$)
            are in $\XP_\Sigma$.
        \item If $e_1, e_2 \in \XP_\Sigma$, then
            $e_1 e_2$ and
            $\Xl e_1 \Xr$
            are in $\XP_\Sigma$.
    \end{enumerate}
    \end{Xdef}


    \begin{Xdef}
    \emph{Tagged Nondeterministic Finite Automaton (TNFA)}
    is a structure $(\Sigma, Q, T, \Delta, q_0, q_f)$, where:
    \begin{itemize}
        \item[] $\Sigma$ is a finite set of symbols (\emph{alphabet})
        \item[] $Q$ is a finite set of \emph{states}
        \item[] $T\subset\YN$ is a finite set of \emph{tags}
        \item[] $\Delta = \Delta^\Sigma \sqcup \Delta^\epsilon$ is the \emph{transition} relation,
            consisting of two parts:
        \begin{itemize}
            \item[] $\Delta^\Sigma \subseteq Q \times \Sigma \times \{\epsilon\} \times Q$ (transitions on symbols)
            \item[] $\Delta^\epsilon \subseteq Q \times \YN \times \big( \YZ \cup \{\epsilon\} \big) \times Q$
                ($\epsilon$-transitions, where $\forall (q, n, \Xund, \Xund), (q, m, \Xund, \Xund) \in \Delta^\epsilon: n \neq m$)
        \end{itemize}
        \item[] $q_0 \in Q$ is the \emph{initial} state
        \item[] $q_f \in Q$ is the \emph{final} state
    \end{itemize}
    \end{Xdef}

As the reader might notice, our definitions are subtly different from the usual ones in literature.
Regular expressions are extended with submatch operator
and generalized repetition (note that it is not just syntactic sugar: in POSIX \texttt{(a)(a)} is semantically different from \texttt{(a)\{2\}},
and \texttt{(a)} in not the same as \texttt{a}).
Parse trees have a special \emph{nil-tree} constructor
and an upper index, which allows us to distinguish between submatch and non-submatch subtrees.
Mirroring parse trees, parenthesized expressions also have a special \emph{nil-parenthesis}.
TNFA is in essence a nondeterministic finite-state transducer
in which some of the $\epsilon$-transitions are marked with \emph{tags}.
Tags are integer numbers that denote opening and closing parentheses of submatch groups:
for $i$-th group, opening tag is $2i - 1$ and closing tag is $2i$ (where $i \in \YN$).
Tags can be negative, which represents the absence of match and corresponds to nil-parenthesis $\Xm$ and nil-tree $\varnothing$.
Additionally, all $\epsilon$-transitions are marked with \emph{priority}
which allows us to impose specific order of TNFA traversal
(all $\epsilon$-transitions from the same state have different priority).
\\

\begin{algorithm}[H] \DontPrintSemicolon \SetKwProg{Fn}{}{}{} \SetAlgoInsideSkip{medskip}
\setstretch{0.8}
\Fn {$\underline{match \big( N \!\!=\! (\Sigma, Q, T, \Delta, q_0, q_f), \; \alpha_1 \!\hdots\! \alpha_n \big)} \smallskip$} {

    $B, D : \YZ^{|Q| \times |Q|}$ \;
    $r_0 = initial \Xund result(T)$ \;
    $X = \big\{ (q_0, \varnothing, \epsilon, r_0) \big\}, \; i = 1$ \;

    \BlankLine
    \While {$i \leq n \wedge X \neq \emptyset$} {
        $X = closure(N, X, B, D)$ \;
        $X = update \Xund result(X, i, \alpha_i)$ \;
        $(B, D) = update \Xund ptables(X, B, D, i)$ \;
        $X = \big\{ (q, o, \epsilon, t) \mid (o, \Xund, \Xund, t) \in X \wedge (o, \alpha_i, \epsilon, q) \in \Delta^\Sigma \big\}$ \;
        $i = i + 1$ \;
    }

    \BlankLine
    $X = closure(N, X, B, D)$ \;
    \If {$(q_f, \Xund, u, r) \in X$} {
        \Return $f\!inal \Xund result (u, r, n)$
    } \lElse {
        \Return $\varnothing$
    }
}
%\caption{Skeleton of the matching algorithm.}
\caption{TNFA simulation on a string.}
\end{algorithm}
\medskip

The algorithm takes automaton $N$ and string $\alpha_1 \!\hdots\! \alpha_n$ as input,
and outputs match result is some form: it can be a parse tree or a POSIX array of offsets,
but for now we leave it unspecified and hide behind functions
$initial \Xund result ()$, $update \Xund result ()$ and $f\!inal \Xund result ()$.
The algorithm works by consuming input symbols,
tracking a set of active \emph{configurations}
and updating \emph{precedence tables} $B$ and $D$.
Configuration is a tuple $(q, o, u, r)$.
The first component $q$ is a TNFA state that is unique for each configuration in the current set.
Components $o$ and $u$ keep information about the path by which $q$ was reached:
$o$ is the \emph{origin} state used as index in precedence tables,
and $u$ is the sequence of tags on path fragment constructed by $closure()$.
Finally, $r$-component is a partial match result associated with state $q$.
Most of the real work happens inside of $closure()$ and $update \Xund ptables ()$, both of which remain undefined for now.
The $closure()$ function builds $\epsilon$-closure of the current configuration set:
it explores all states reachable by $\epsilon$-transitions from the $q$-components
and tracks the best path to each reachable state.
The $update \Xund ptables ()$ function
performs pairwise comparison of all configurations in the new set,
recording results in $B$ and $D$ matrices.
On the next step $q$-components become $o$-components.
If paths originating from current configurations meet on some future step,
$closure ()$ will use origin states to lookup comparison results in $B$ and $D$ matrices.
On the other hand, if the paths do not meet, then comparison performed by $update \Xund ptables ()$ is redundant.
Unfortunately we cannot get rid of redundant comparisons:
we do not know in advance which configurations will spawn ambiguous paths.
It is possible to delay disambiguation until the paths meet,
but that would require keeping arbitrary long paths in memory.
Eager comparison is a tradeoff that allows the algorithm work in bounded memory at the expense of some time overhead.
\\

%\vfill\null

\section{Formalization}

According to the POSIX standard,
submatch extraction applies only to parenthesized subexpressions,
but the longest-match rule applies to all subexpressions regardless of parentheses.
Therefore first of all we rewrite REs in a form that makes submatch information explicit.
Namely, we equip every subexpression with an \emph{implicit} and \emph{explicit} submatch index.
Explicit indices enumerate submatch groups; for all other subexpressions they are zero.
Implicit indices enumerate submatch groups and subexpressions that are not submatch groups,
but contain nested or sibling groups and need to be considered by disambiguation.
%If both indices are zero, then the subexpression is completely ignored from disambiguation perspective.
%Indices are convenient because they allow us to consider individual sub-REs
%without loosing the submatch context of the whole RE.

    \begin{Xdef}
    \emph{Indexed regular expressions (IRE)} over finite alphabet $\Sigma$, denoted $\XIR_\Sigma$:
    \begin{enumerate}
        \item
          Empty IRE $(i, j, \epsilon)$ and
          unit IRE $(i, j, \alpha)$, where $\alpha \in \Sigma$ and $i, j \in \YZ$,
          are in $\XIR_\Sigma$.

        \item If $r_1, r_2 \in \XIR_\Sigma$ and $i, j \in \YZ$, then
          union $(i, j, r_1 \mid r_2)$,
          product $(i, j, r_1 \cdot r_2)$ and
          repetition $(i, j, r_1^{n, m})$, where $0 \leq n \leq m \leq \infty$,
          are in $\XIR_\Sigma$.
    \end{enumerate}
    \end{Xdef}

Function $\IRE$ transforms RE into IRE.
It is defined via a composition of two functions,
$mark()$ that transforms RE into IRE with submatch indices in the boolean range $\{0, 1\}$,
and $enum()$ that substitutes boolean indices with consecutive numbers.
%$\IRE(e) = r$ where $(\Xund, \Xund, r) = enum(1, 1, mark(e))$.
%Note that we consider $(e)$ as a special case of repetition $(e)^{1,1}$:
%this allows us to handle all parenthesized sub-RE uniformly.
An example of constructing an IRE from a RE is given on figure \ref{fig_mark_enum}.
%The reverse transformation is also possible by erasing all indices
%and adding parentheses around subexpressions with nonzero explicit submatch index.
%Therefore RE and IRE are equivalent representations.

    \begin{align*}
    &\begin{aligned}
        mark &: \XR_\Sigma \longrightarrow \XIR_\Sigma \\
        mark &(x) \mid_{x \in \{\epsilon, \alpha\}} = (0, 0, x) \\[-0.2em]
        %
        mark &(e_1 \circ e_2) \mid_{\circ \in \{|,\cdot\}} = (i, 0,
            (i, j_1, r_1) \circ
            (i, j_2, r_2)
            ) \\[-0.2em]
            &\text{where }            (i_1, j_1, r_1) = mark(e_1) \\[-0.2em]
            &\space{\hphantom{where }}(i_2, j_2, r_2) = mark(e_2) \\[-0.2em]
            &\space{\hphantom{where }}i = i_1 \vee i_2 \\[-0.2em]
        %
        mark &(e^{n, m}) \mid_{e = (e_1)} = (1, 0, (1, 1, r)) \\[-0.2em]
            &\text{where } (\Xund, \Xund, r) = mark(e_1) \\[-0.2em]
        %
        mark &(e^{n, m}) \mid_{e \neq (e_1)} = (i, 0, (i, j, r)) \\[-0.2em]
            &\text{where } (i, j, r) = mark(e) \\[-0.2em]
        %
        mark &((e)) = mark((e)^{1, 1})
    \end{aligned}
    %
    &&\begin{aligned}
        enum &: \YZ \times \YZ \times \XIR_\Sigma \longrightarrow \YZ \times \YZ \times \XIR_\Sigma \\
        enum &(\bar{i}, \bar{j}, (i, j, x)) \mid_{x \in \{\epsilon, \alpha\}}
            = (\bar{i} + i, \bar{j} + j, (\bar{i} \times i, \bar{j} \times j, x))
        \\[-0.2em]
        enum &(\bar{i}, \bar{j}, (i, j, r_1 \circ r_2)) \mid_{\circ \in \{|,\cdot\}}
            = (i_2, j_2, (\bar{i} \times i, \bar{j} \times j, \bar{r}_1 \circ \bar{r}_2)) \\[-0.2em]
            &\text{where }            (i_1, j_1, \bar{r}_1) = enum(\bar{i} + i, \bar{j} + j, r_1) \\[-0.2em]
            &\space{\hphantom{where }}(i_2, j_2, \bar{r}_2) = enum(i_1, j_1, r_2)
        \\[-0.2em]
        enum &(\bar{i}, \bar{j}, (i, j, r^{n,m})) = (i_1, j_1, (\bar{i} \times i, \bar{j} \times j, \bar{r}^{n,m})) \\[-0.2em]
            &\text{where }
                (i_1, j_1, \bar{r}) = enum(\bar{i} + i, \bar{j} + j, r)
        \\[-0.2em]
        \\[-0.2em]
        \IRE &: \XR_\Sigma \rightarrow \XIR_\Sigma \\[-0.2em]
        \IRE&(e) = r \\[-0.2em]
            &\text{where }(\Xund, \Xund, r) = enum(1, 1, mark(e))
        \\[-0.2em]
    \end{aligned}
    \end{align*}
    \medskip

The relation between regular expressions and parse trees is given by the operator $\PT$.
Each IRE denotes a set of PTs:

    \begin{align*}
        \PT &: \XIR_\Sigma \rightarrow 2^{\XT_\Sigma}
        \\
        \PT\big((i, \Xund, \epsilon)\big) &= \{ {\epsilon}^{i} \}
        \\[-0.2em]
        \PT\big((i, \Xund, \alpha)\big) &= \{ {\alpha}^{i} \}
        \\[-0.2em]
        \PT\big((i, \Xund, (i_1, j_1, r_1) \mid (i_2, j_2, r_2))\big) &=
            \big\{ {T}^{i}(t, \varnothing^{i_2}) \mid t \in \PT\big((i_1, j_1, r_1)\big) \big\} \cup
            \big\{ {T}^{i}(\varnothing^{i_1}, t) \mid t \in \PT\big((i_2, j_2, r_2)\big) \big\}
        \\[-0.2em]
        \PT\big((i, \Xund, (i_1, j_1, r_1) \cdot (i_2, j_2, r_2))\big) &=
            \big\{ {T}^{i}(t_1, t_2) \mid
                t_1 \in \PT\big((i_1, j_1, r_1)\big),
                t_2 \in \PT\big((i_2, j_2, r_2)\big)
            \big\} \\[-0.2em]
        \PT\big((i, \Xund, (i_1, j_1, r_1)^{n, m})\big) &=
            \begin{cases}
                \big\{ {T}^{i}(t_1, \dots, t_m) \mid t_k \in \PT\big((i_1, j_1, r_1)\big) \;
                    \forall k = \overline{1, m} \big\} \cup \{ {T}^{i}(\varnothing^{i_1}) \} &\text{if } n = 0 \\[-0.2em]
                \big\{ {T}^{i}(t_n, \dots, t_m) \mid t_k \in \PT\big((i_1, j_1, r_1)\big) \;
                    \forall k = \overline{n, m} \big\} &\text{if } n > 0
            \end{cases}
    \end{align*}
    \medskip

We write $str(t)$ to denote the string formed by concatenation of all alphabet symbols in the left-to-right traversal of $t$,
and $\PT(r, w)$ denotes the set $\big\{ t \in \PT(\IRE(r)) \mid str(t) = w \big\}$ of all PTs for a RE $r$ and a string $w$.

    \begin{Xdef}\label{ambiguity_of_parse_trees}
    PTs $s$ and $t$ are \emph{ambiguous} iff $s \neq t$ and $s, t \in PT(r, w)$ for some RE $r$ and string $w$.
    $\square$
    \end{Xdef}

Following \ref{OS13}, we assign \emph{positions} to the nodes of RE and PT.
The root position is $\Lambda$, and position of the $i$-th subtree of a tree with position $p$ is $p.i$
(we shorten $\|t\|_\Lambda$ as $\|t\|$).
The \emph{length} of position $p$, denoted $|p|$, is defined as $0$ for $\Lambda$ and $|p| + 1$ for $p.i$.
%The set of all positions is denoted $\XP$.
The subtree of a tree $t$ at position $p$ is denoted $t|_p$.
Position $p$ is a \emph{prefix} of position $q$ iff $q = p.p'$ for some $p'$,
and a \emph{proper prefix} if additionaly $p \neq q$.
Position $p$ is a \emph{sibling} of position $q$ iff $q = q'.i, p = q'.j$ for some $q'$ and $i,j \in \YN$.
Positions are ordered lexicographically.
The set of all positions of a tree $t$ is denoted $Pos(t)$.
Additionally, we define a set of \emph{submatch positions} as
$Sub(t) = \big\{ p \mid \exists t|_p = s^i : i \neq 0 \big\}$ ---
a subset of $Pos(t)$ that contains positions of subtrees with nonzero implicit submatch index.
Intuitively, this is the set of positions important from disambiguation perspective:
in the case of ambiguity we do not need to consider the full trees,
just the relevant parts of them.
%
PTs have two definitions of norm, one for $Pos$ and one for $Sub$,
which we call \emph{p-norm} and \emph{s-norm} respectively:

\begin{figure}\label{fig_mark_enum}
\includegraphics[width=\linewidth]{img/mark_enum.pdf}
\vspace{-2em}
\caption{
IRE for RE $(\epsilon|a^{0,\infty})(a|\epsilon)^{0,3}$
and examples of PTs for string $a$.
S-norm is marked with $\#$.
}
\end{figure}

%\FloatBarrier

    \begin{Xdef}\label{tnorm_of_PTs}
    The \emph{p-norm} and \emph{s-norm} of a PT $t$ at position $p$ are:
    \begin{align*}
        \pnorm{t}{p} =
            \begin{cases}
                -1          &\text{if } p \in Pos(t) \text{ and } t|_p = \varnothing^i  \\[-0.2em]
                |str(t|_p)| &\text{if } p \in Pos(t) \text{ and } t|_p \neq \varnothing^i \\[-0.2em]
                \infty      &\text{if } p \not\in Pos(t)
            \end{cases}
    \quad\quad\quad
        \snorm{t}{p} =
            \begin{cases}
                -1          &\text{if } p \in Sub(t) \text{ and } t|_p = \varnothing^i  \\[-0.2em]
                |str(t|_p)| &\text{if } p \in Sub(t) \text{ and } t|_p \neq \varnothing^i \\[-0.2em]
                \infty      &\text{if } p \not\in Sub(t)
            \end{cases}
    \end{align*}
    \end{Xdef}

Generally the norm of a subtree means the number of alphabet symbols in its leaves, with two exceptions.
First, for nil subtrees the norm is $-1$: intuitively, they have the lowest ``ranking'' among all possible subtrees.
Second, for inexistent subtrees (those with positions not in $Pos(t)$) the norm is infinite.
This may seem counterintuitive at first, but it makes sense in the presense of REs with empty repetition.
According to the POSIX, optional empty repetitions are not allowed, and our definition reflects this:
if a tree $s$ has a subtree $s|_p$ corresponding to an empty repetition,
and another tree $t$ has no subtree at position $p$,
then the infinite norm $\|t\|_p$ ``outranks'' $\|s\|_p$.
We define two orders on PTs:

    \begin{Xdef}\label{total_order_on_PTs}
    \emph{P-order on PTs.}
    Given parse trees $t, s \in PT(e, w)$, we say that $t <_p s$ w.r.t. \emph{desision position} $p$
    iff $\pnorm{t}{p} > \pnorm{s}{p}$ and $\pnorm{t}{q} = \pnorm{s}{q} \; \forall q < p$.
    We say that $t < s$ iff $t <_p s$ for some $p$.
    \end{Xdef}

    \begin{Xdef}\label{partial_order_on_PTs}
    \emph{S-order on PTs.}
    Given parse trees $t, s \in PT(e, w)$, we say that $t \prec_p s$ w.r.t. \emph{desision position} $p$ % $p \in Sub(t) \cup Sub(s)$
    iff $\snorm{t}{p} > \snorm{s}{p}$ and $\snorm{t}{q} = \snorm{s}{q} \; \forall q < p$.
    We say that $t \prec s$ iff $t \prec_p s$ for some $p$.
    \end{Xdef}

    \begin{Xdef}\label{incomparable_IPTs}
    IPTs $t$ and $s$ are \emph{incomparable}, denoted $t \sim s$,
    iff neither $t \prec s$, nor $s \prec t$.
    \end{Xdef}

    \begin{XThe}\label{theorem_porder_on_PTs}
    P-order $<$ is a strict total order on IPTs.
    (Proof given in appendix [??].)
    \end{XThe}

    \begin{XThe}\label{theorem_sorder_on_PTs}
    S-order $\prec$ is a strict weak order on IPTs.
    (Proof given in appendix [??].)
    \end{XThe}

P-order is total --- the $<$-minimal tree is unique.
S-order is partial:
there might be two distinct PTs that coincide in all submatch positions, yet differ in some non-submatch positions.
Such trees are called \emph{incomparable},
and from disambiguation perspective they are indistinguishable.
%
Incomparability is an equivalence relation: it is
reflexive (obviously $s \sim s$),
symmetric (obviously $s \sim t$ implies $t \sim s$) and
transitive (see lemma \ref{lemma_ptorder_transitivity_of_incomparability} in appendix).
Consequently there is a whole class of $\prec$-minimal trees.
%$\PT_{min}(r,w) = \{ t \in \PT(r,w) \mid \forall u \in \PT(r,w) : t \sim u \vee t < u \}$.
%
One might ask, what is the relation between p-order $<$ and s-order $\prec$?
We show by the means of a counterexample that p-order is not an extension of s-order.
Consider trees $t$ and $u$ on figure \ref{fig_mark_enum}:
on one hand $t \prec_{2.2} u$, because $\snorm{t}{2.2} = \infty > 0 = \snorm{u}{2.2}$ and s-norms at all preceding submatch positions agree;
on the other hand $u <_{1.1} t$, because $\pnorm{t}{1.1} = -1 < 0 = \pnorm{u}{1.1}$
and p-norms at all preceding positions agree.
So the two orders may disagree.
However, as theorem \ref{theorem_order_compat} shows,
the two orders agree on the notion of minimal tree.
%
This is important, as it means that adding a few parentheses in RE will not drastically change submatch results:
we will continuously narrow down the class of $\prec$-minimal trees
until we are left with a unique $<$-minimal tree.
In the rest of the paper the words ``order'' and ``norm`` refer to s-order and s-norm.

    \begin{XThe}\label{theorem_order_compat}
    For an IRE $r$ and string $w$,
    let $t_{min}$ be the $<$-minimal tree in $\PT(r,w)$
    and let $T_{min} = \PT_{min}(r,w)$ be the class of the $\prec$-minimal trees in $\PT(r,w)$.
    Then $t_{min} \in T_{min}$.
    (Proof given in appendix [??].)
    \end{XThe}

Following the idea of Okui and Suzuki,
we go from comparison of parse trees to comparison of their linearized representation --- parenthesized expressions.
Parenthesis $\Xl$ is opening, and
parenthesis $\Xr$ is closing;
the \emph{nil}-parenthesis $\Xm$ is both opening and closing.
For convenience we sometimes annotate parentheses with \emph{height},
which we define as the number of preceding opening parentheses (including this one)
minus the number of preceding closing parentheses (including this one).
Explicit height annotations allow us to consider PE fragments in isolation
without losing the context of the whole expression.
However, height is not a part of parenthesis itself,
and it is not taken into account when comparing the elements of PEs.
Function $\Phi$ transforms PT at the given height into PE:

    \begin{align*}
    \Phi &: \YZ \times \XT_\Sigma \rightarrow \XP_\Sigma
    \\
    \Phi_{h}(t^{i}) &= \begin{cases}
        str(t^{i})                                            &\text{if } i = 0 \\[-0.2em]
        \Xm_h                                                 &\text{if } i \neq 0 \wedge t = \varnothing \\[-0.2em]
        \Xl_{h+1} \Xr_h                                       &\text{if } i \neq 0 \wedge t = \epsilon \\[-0.2em]
        \Xl_{h+1} a \Xr_h                                     &\text{if } i \neq 0 \wedge t = a \in \Sigma \\[-0.2em]
        \Xl_{h+1} \Phi_{h+1}(t_1) \dots \Phi_{h+1}(t_n) \Xr_h &\text{if } i \neq 0 \wedge t = T(t_1, \dots, t_n)
    \end{cases}
    \end{align*}
    \medskip

For a given RE $r$ and string $w$, the set $\big\{ \Phi_{0}(t) \mid t \in PT(r, w) \big\}$ is denoted $\PE(r, w)$.
If $\alpha, \beta \in \PE(r, w)$ for some $r$ and $w$, we say that $\alpha$ and $\beta$ are \emph{comparable}.
%
For PE $\alpha$ and $\beta$,
$\alpha \sqcap \beta$ denotes the longest common prefix of $\alpha$ and $\beta$,
$\alpha \backslash \beta$ denotes the suffix of $\alpha$ after removing $\alpha \sqcap \beta$,
$lasth(\alpha)$ denotes the height of the last parenthesis in $\alpha$ (or $\infty$ if $\alpha$ is empty or begins with a letter),
$minh(\alpha)$ denotes the minimal height of parenthesis in $\alpha$ (or $\infty$ if $\alpha$ is empty or begins with a letter),
$first(\alpha)$ denotes the first parenthesis in $\alpha$ (or $\bot$ if $\alpha$ is empty or begins with a letter).
Each PE $\alpha$ can be represented as $\alpha_0 a_1 \alpha_1 \dots a_n \alpha_n$,
where $\alpha_i$ is the $i$-th \emph{frame} --- a possibly empty sequence of parentheses between
subsequent alphabet symbols $a_i$ and $a_{i+1}$ (or the beginning or end of $\alpha$).
For comparable PE $\alpha$ and $\beta$ the index of the first distinct pair of frames is called \emph{fork}
(note that comparable PE have the same number of frames).

\begin{figure}\label{fig_pe}
\includegraphics[width=\linewidth]{img/pe.pdf}
\vspace{-2em}
\caption{
Examples: (a) -- (d): four main rules of POSIX comparison,
(e) -- pairwise comparison of PEs.
}
\end{figure}

%\FloatBarrier

    \begin{Xdef}
    Let $\alpha$, $\beta$ be distinct comparable PE, such that
    $\alpha = \alpha_0 a_1 \alpha_1 \dots a_n \alpha_n$,
    $\beta = \beta_0 a_1 \beta_1 \dots a_n \beta_n$ and $k$ is the fork.
    We define $trace (\alpha, \beta)$ as the sequence $(\rho_0, \dots, \rho_n)$, where:
    $$
    \rho_i = \begin{cases}
        -1 &\text{if } i < k \\[-0.2em]
        min (lasth (\alpha_i \sqcap \beta_i), minh(\alpha_i \backslash \beta_i)) &\text{if } i = k \\[-0.2em]
        min (\rho_{i-1}, minh(\alpha_i)) &\text{if } i > k
    \end{cases}
    $$
    We write $traces(\alpha, \beta)$ to denote $\big( trace (\alpha, \beta), trace (\beta, \alpha) \big)$.
    \end{Xdef}

    \begin{Xdef}\label{prec1}
    Let $\alpha$, $\beta$ be comparable PE and
    $traces(\alpha, \beta) = \big( (\rho_0, \dots, \rho_n), (\rho'_0, \dots, \rho'_n) \big)$.
    The \emph{longest-precedence} relation $\sqsubset$ is defined as
    $\alpha \sqsubset \beta \Leftrightarrow \exists i \leq n:
        \big( \rho_i > \rho'_i \big) \wedge
        \big( \rho_j = \rho'_j \; \forall j > i \big)$.
    If neither $\alpha \sqsubset \beta$, nor $\beta \sqsubset \alpha$,
    then $\alpha$, $\beta$ are \emph{longest-equivalent}: $\alpha \sim \beta$
    (note that in this case $\rho_i = \rho'_i \; \forall i = \overline {1, n}$).
    \end{Xdef}

    \begin{Xdef}\label{prec2}
    Let $\alpha$, $\beta$ be comparable PE, and let
    $x = first (\alpha \backslash \beta)$,
    $y = first (\beta \backslash \alpha)$.
    The \emph{leftmost-precedence} relation $\subset$ is defined as
    $\alpha \subset \beta \Leftrightarrow x < y$, where
    the set of possible values of $x$ and $y$ is ordered as follows:
    $\bot < \Xr < \Xl < \Xm$.
    \end{Xdef}

    \begin{Xdef}\label{pe_order}
    The \emph{longest-leftmost-precedence} relation $<$ on comparable PE is defined as
    $\alpha < \beta \Leftrightarrow
        \big( \alpha \sqsubset \beta \big) \vee
        \big( \alpha \sim \beta \wedge \alpha \subset \beta \big)$.
    \end{Xdef}

    \begin{XThe}\label{theorem_order_on_pe_same_as_on_pt}
    Let $s, t \in PT(r, w)$, then
    $s <_p t \Leftrightarrow \Phi_{h}(s) < \Phi_{h}(t) \; \forall h$.
    \end{XThe}


\section{Comparison of tag histories}

\begin{algorithm}[H] \DontPrintSemicolon \SetKwProg{Fn}{}{}{} \SetAlgoInsideSkip{medskip}
\begin{multicols}{2}
    \setstretch{0.8}
    \newcommand \ff {f\!\!f}

    \Fn {$\underline {compare ((\Xund, o_1, n_1, \Xund), (\Xund, o_2, n_2, \Xund), B, D)} \smallskip$} {
        \If { $o_1 = o_2 \wedge n_1 = n_2$ } {
            \Return $(\infty, \infty, 0)$
        }

        \BlankLine
        \lIf {$o_1 = o_2$ } {
            $h_1 = h_2 = \infty$
        }
        \lElse {
            $h_1 = B[o_1][o_2], \; h_2 = B[o_2][o_1]$
        }

        \BlankLine
        $m_1 = m_2 = \bot$ \;
        \While {$n_1 \neq n_2$} {
            \If {$n_1 > n_2$} {
                $h_1 = min(h_1, height(H, n_1))$ \;
                $m_1 = n_1, n_1 = pred(H, n_1)$ \;
            }
            \Else {
                $h_2 = min(h_2, height(H, n_2))$ \;
                $m_2 = n_2, n_2 = pred(H, n_2)$ \;
            }
        }
        \If {$n_1 \neq \bot$} {
            $h_1 = min(h_1, height(H, n_1))$ \;
            $h_2 = min(h_2, height(H, n_1))$ \;
        }

        \BlankLine
        $l = prec (h_1, h_2, o_1, o_2, m_1, m_2, H, D)$ \;
        \Return $(h_1, h_2, l)$ \;
    }
    \BlankLine
    \BlankLine

    \Fn {$\underline {prec (h_1, h_2, o_1, o_2, n_1, n_2, H, D)} \smallskip$} {
        \lIf {$h_1 > h_2$} { \Return $-1$ }
        \lIf {$h_1 < h_2$} { \Return $1$ }

        \BlankLine
        \lIf {$o_1 \neq o_2$} { \Return $D[o_1][o_2]$ }

        \BlankLine
        \lIf {$n_1 = n_2$} { \Return $0$ }
        \lIf {$n_1 = \bot$} { \Return $-1$ }
        \lIf {$n_2 = \bot$} { \Return $1$ }

        \BlankLine
        $t_1 = tag(H, n_1), \; t_2 = tag(H, n_2)$ \;

        \BlankLine
        \lIf {$t_1 mod \, 2 \equiv 0$} { \Return $-1$ }
        \lIf {$t_2 mod \, 2 \equiv 0$} { \Return $1$ }

        \BlankLine
        \lIf {$t_1 < 0$} { \Return $1$ }
        \lIf {$t_2 < 0$} { \Return $-1$ }

        \BlankLine
        \Return $0$
    }
    \BlankLine
    \BlankLine

    \Fn {$\underline {update \Xund ptables (X, B, D)} \smallskip$} {
        \For {$x_1 = (q_1, \Xund, \Xund, \Xund) \in X$} {
            \For {$x_2 = (q_2, \Xund, \Xund, \Xund) \in X$} {
                $(h_1, h_2, l) = compare (x_1, x_2, B, D)$ \;
                $B' [q_1] [q_2] = h_1, \; D' [q_1] [q_2] = l$ \;
                $B' [q_2] [q_1] = h_2, \; D' [q_2] [q_1] = -l$
            }
        }
        \BlankLine
        \Return $(B', D')$ \;
    }

    \vfill
    \columnbreak

    \Fn {$\underline {update \Xund ptables (X, B, D)} \smallskip$} {
        $n_0 = root(H), \; i = 0, \; next(n) = 1 \; \forall n$ \;
        $push(S, n_0)$ \;

        \BlankLine
        \While {$S$ is not empty} {
            $n = pop(S)$ \;
            $\{m_1, \hdots, m_k \} = succ(H, n)$ \;

            \BlankLine
            \If {$next(n) < k$} {
                $push(S, n)$ \;
                $push(S, m_{next(n)})$ \;
                $next(n) = next(n) + 1$ \;
                $continue$ \;
            }

            \BlankLine
            $h = height(H, n), \; i_1 = i$ \;

            \BlankLine
            \For {$(q, o, n_1, \Xund) \in X \mid n_1 = n$} {
                $i = i + 1, \; L[i] = (q, o, \bot, h)$ \;
            }
            \For {$j_1 = \overline{i_1 + 1, i}$} {
                \For {$j_2 = \overline{j_1, i}$} {
                    $(q_1, o_1, \Xund, \Xund) = L[j_1]$ \;
                    $(q_2, o_2, \Xund, \Xund) = L[j_2]$ \;

                    \BlankLine
                    \If {$n = n_0 \wedge o_1 \neq o_2$} {
                        $h_1 = B[o_1][o_2]$ \;
                        $h_2 = B[o_2][o_1]$ \;
                        $l = D[o_1][o_2]$ \;
                    }
                    \lElse {
                        $h_1 = h_2 = h, \; l = 0$
                    }

                    \BlankLine
                    $B'[q_1][q_2] = h_1, \; D'[q_1][q_2] = l$ \;
                    $B'[q_2][q_1] = h_2, \; D'[q_2][q_1] = -l$ \;
                }
            }

            \BlankLine
            \For {$m \in \{m_k, \dots, m_1 \}$} {
                $i_2 = i_1$ \;
                \lWhile {$i_2 > 0 \wedge L[i_2].n = m$} {
                    $i_2 = i_2 - 1$
                }

                \BlankLine
                \For {$j_1 = \overline{i_2, i_1}$} {
                    $L[j_1].h = min(L[j_1].h, h)$; \;

                    \BlankLine
                    \For {$j_2 = \overline{i_1, i}$} {
                        $(q_1, o_1, n_1, h_1) = L[j_1]$ \;
                        $(q_2, o_2, n_2, h_2) = L[j_2]$ \;

                        \BlankLine
                        \If {$n = n_0 \wedge o_1 \neq o_2$} {
                            $h_1 = min(h_1, B[o_1][o_2])$ \;
                            $h_2 = min(h_2, B[o_2][o_1])$ \;
                        }

                        \BlankLine
                        $l = prec (h_1, h_2, o_1, o_2, n_1, n_2, H, D)$ \;
                    }

                    \BlankLine
                    $B'[q_1][q_2] = h_1, \; D'[q_1][q_2] = l$ \;
                    $B'[q_2][q_1] = h_2, \; D'[q_2][q_1] = -l$ \;
                }

                $i_1 = i_2$ \;
            }

            \BlankLine
            \lFor {$j = \overline{i_1, i}$} {
                $L[j].n = n$
            }
        }

        \BlankLine
        \Return $(B', D')$ \;
    }

\end{multicols}
\vspace{1em}
\caption{Comparison of tag histories.}
\end{algorithm}
\medskip


\section{Representation of match results}

\begin{algorithm}[H] \DontPrintSemicolon \SetKwProg{Fn}{}{}{}
\begin{multicols}{2}
    \setstretch{0.8}

    \Fn {$\underline{initial \Xund result (T)} \smallskip$} {
        \For {$i = \overline {0, |T| / 2}$} {
            $pmatch[i].rm \Xund so = -1$ \;
            $pmatch[i].rm \Xund eo = -1$ \;
        }
        \Return $pmatch$ \;
    }
    \BlankLine

    \Fn {$\underline{update \Xund result (X, k, \Xund)} \smallskip$} {
        \Return $\big\{ (q, o, u, apply \Xund tags (u, r, k)) \mid (q, o, u, r) \in X \big\}$ \;
        %\For {$(q, o, t_1 \hdots t_n, pmatch) \in X$} {
        %    \For {$i = \overline {1, n}$} {
        %        \lIf {$t_i < 0$} {$l = -1$}
        %        \lElse {$l = k$}
        %        \lIf {$t_i mod \, 2 \equiv 0$} {$pmatch[|t_i|/2].rm \Xund so = l$}
        %        \lElse {$pmatch[(|t_i| - 1)/2].rm \Xund eo = l$}
        %    }
        %}
        %\Return $X$ \;
    }
    \BlankLine

    \Fn {$\underline{f\!inal \Xund result (u, r, k)} \smallskip$} {
        $pmatch = apply \Xund tags (u, r, k)$ \;
        $pmatch[0].rm \Xund so = 0$ \;
        $pmatch[0].rm \Xund eo = k$ \;
        \Return $pmatch$ \;
    }
    \BlankLine

    \Fn {$\underline{apply \Xund tags (t_1 \hdots t_n, pmatch, k)} \smallskip$} {
        \For {$i = \overline {1, n}$} {
            \lIf {$t_i < 0$} {$l = -1$}
            \lElse {$l = k$}
            \lIf {$t_i mod \, 2 \equiv 0$} {$pmatch[|t_i|/2].rm \Xund eo = l$}
            \lElse {$pmatch[(|t_i| \!+\! 1)/2].rm \Xund so = l$}
        }
        \Return $pmatch$ \;
    }
    \BlankLine

    \vfill

\columnbreak

    \Fn {$\underline{initial \Xund result (\Xund)} \smallskip$} {
        \Return $\epsilon$ \;
    }
    \BlankLine

    \Fn {$\underline{update \Xund result (X, \Xund, \alpha)} \smallskip$} {
        \Return $\big\{ (q, o, u, r \cdot u \cdot \alpha) \mid (q, o, u, r) \in X \big\}$ \;
    }
    \BlankLine

    \Fn {$\underline{f\!inal \Xund result (u, r, \Xund)} \smallskip$} {
        \Return $parse \Xund tree (r \cdot u, 1)$ \;
    }
    \BlankLine

    \Fn {$\underline{parse \Xund tree (u, i)} \smallskip$} {
        \If {$u = (2i \!-\! 1) \cdot (2i)$} {
            \Return $T^i(\epsilon)$
        }
        \If {$u = (1 \!-\! 2i) \cdot \hdots $} {
            \Return $T^i(\varnothing)$
        }
        \If {$u = (2i \!-\! 1) \cdot \alpha_1 \hdots \alpha_n \cdot (2i) \wedge \alpha_1, \hdots, \alpha_n \in \Sigma $} {
            \Return $T^i(a_1, \hdots, a_n)$
        }
        \If {$u = (2i \!-\! 1) \cdot \beta_1 \hdots \beta_m \cdot (2i) \wedge \beta_1 = 2j \!-\! 1 \in T$} {
            $n = 0, k = 1$ \;
            \While {$k \leq m$} {
                $l = k$ \;
                \lWhile {$|\beta_{k+1}| > 2j$} {
                    $k = k + 1$
                }
                $n = n + 1$ \;
                $t_n = parse \Xund tree (\beta_l \dots \beta_k, j)$
            }
            \Return $T^i(t_1, \dots, t_n)$
        }
        \Return $\varnothing$ \tcp{ill-formed PE}
    }
    \BlankLine

\end{multicols}
\vspace{1.5em}
\caption{Construction of match results: POSIX offsets (on the left) and parse tree (on the right).}
\end{algorithm}
\medskip


\section{Tagged NFA}

TNFA construction is given by the $F$ function defined on figure \ref{fig_tnfa}.


\begin{figure*}
\begin{multicols}{2}
\fontsize{8}{10}
    \setstretch{0.8}

    %\fontsize{9.5pt}{11.5pt}\selectfont

    %\newcommand \retonfa {re \Xund to \Xund n\!f\!a}
    %\newcommand \ntag {neg \Xund tag}
    \newcommand \retonfa {F}
    \newcommand \ntag {N}

    \begin{algorithm}[H] \DontPrintSemicolon \SetKwProg{Fn}{}{}{}
    \Fn {$\underline{\retonfa(r, y)} \smallskip$} {
        \If {$r = (0, 0, \epsilon)$} {
            \Return $(\Sigma, \{y\}, \emptyset, \emptyset, y, y)$
        }
        \BlankLine
        \ElseIf {$r = (0, 0, \alpha) \mid_{\alpha \in \Sigma}$} {
            \Return $(\Sigma, \{x,y\}, \emptyset, \{(x, \alpha, \epsilon, y)\}, x, y)$
        }
        \BlankLine
        \ElseIf {$r = (0, 0, s \cdot u)$} {
            $(\Sigma, Q_s, T_s, \Delta_1, x, y) = \retonfa (s, y)$ \;
            $(\Sigma, Q_u, T_u, \Delta_2, z, x) = \retonfa (u, x)$ \;
            \Return $(\Sigma, Q_s \cup Q_u, T_s \cup T_u, \Delta_s \cup \Delta_u, z, y)$
        }
        \BlankLine
        \ElseIf {$r = (0, 0, s \mid u)$} {
            $(\Sigma, Q_1, T_1, \Delta_1, x_1, y) = \ntag (u, y)$ \;
            $(\Sigma, Q_2, T_2, \Delta_2, x_2, x_1) = \retonfa (s, x_1)$ \;
            $(\Sigma, Q_3, T_3, \Delta_3, x_3, y) = \retonfa (u, y)$ \;
            $(\Sigma, Q_4, T_4, \Delta_4, x_4, x_3) = \ntag (s, x_3)$ \;
            $Q = Q_1 \cup Q_2 \cup Q_3 \cup Q_4 \cup \{x\}$ \;
            $T = T_1 \cup T_2 \cup T_3 \cup T_4$ \;
            $\Delta = \Delta_1 \cup \Delta_2 \cup \Delta_3 \cup \Delta_4 \cup \{(x,1,\epsilon,x_2), (x,2,\epsilon,x_4)\}$ \;
            \Return $(\Sigma, Q, T, \Delta, x, y)$
        }
        \BlankLine
        \ElseIf {$r = (0, 0, s^{n,m}) \mid_{n > 0}$} {
            $(\Sigma, Q_1, T_1, \Delta_1, x, y) = \retonfa ((0, 0, s^{n-1,m}), y)$ \;
            $(\Sigma, Q_2, T_2, \Delta_2, z, x) = \retonfa (s, x)$ \;
            \Return $(\Sigma, Q_1 \cup Q_2, T_1 \cup T_2, \Delta_1 \cup \Delta_2, z, y)$
        }
        \BlankLine
        \ElseIf {$r = (0, 0, s^{0,m})$} {
            $(\Sigma, Q_1, T_1, \Delta_1, x_1, y) = \retonfa ((0, 0, s^{1,m}), y)$ \;
            $(\Sigma, Q_2, T_2, \Delta_2, x_2, y) = \ntag (s, y)$ \;
            $Q = Q_1 \cup Q_2 \cup \{x\}$ \;
            $\Delta = \Delta_1 \cup \Delta_2 \cup \{(x,1,\epsilon,x_1), (x,2,\epsilon,x_2)\}$ \;
            \Return $(\Sigma, Q, T_1 \cup T_2, \Delta, x, y)$
        }
        \BlankLine
        \ElseIf {$r = (0, 0, s^{1,\infty})$} {
            $(\Sigma, Q_1, T_1, \Delta_1, z, x) = \retonfa (s, \Xund)$ \;
            $Q = Q_1 \cup \{y\}$ \;
            $\Delta = \Delta_1 \cup \{(x,1,\epsilon,z), (x,2,\epsilon,y)\}$ \;
            \Return $(\Sigma, Q, T_1, \Delta, z, y)$
        }
        \BlankLine
        \ElseIf {$r = (0, 0, s^{1,1})$} {
            \Return $\retonfa (s, y)$
        }
        \BlankLine
        \ElseIf {$r = (0, 0, s^{1,m}) \mid_{1 < m < \infty}$} {
            $(\Sigma, Q_1, T_1, \Delta_1, x, y) = \retonfa ((0, 0, s^{1,m-1}), y)$ \;
            $(\Sigma, Q_2, T_2, \Delta_2, w, z) = \retonfa (r_1, \Xund)$ \;
            $\Delta = \Delta_1 \cup \Delta_2 \cup \{(z,1,\epsilon,y), (z,2,\epsilon,x)\}$ \;
            \Return $(\Sigma, Q_1 \cup Q_2, T_1 \cup T_2, \Delta, w, y)$
        }
        \BlankLine
        \ElseIf {$r = (i, \Xund, s) \mid_{i \neq 0}$} {
            $(\Sigma, Q_1, T_1, \Delta_1, z, x) = \retonfa (s, \Xund)$ \;
            $Q = Q_1 \cup \{w, y\}$ \;
            $T = T_1 \cup \{2i\!-\!1, 2i\}$ \;
            $\Delta = \Delta_1 \cup \{(w,1,2i\!-\!1,z), (x,1,2i,y)\}$ \;
            \Return $(\Sigma, Q, T, \Delta, w, y)$
        }
    }
    \end{algorithm}


    \begin{algorithm}[H] \DontPrintSemicolon \SetKwProg{Fn}{}{}{}
    \Fn {$\underline{\ntag(r)} \smallskip$} {
        $T = \{ t_1, \dots, t_n \} = T(r), n \geq 0$ \;
        $Q = \{x_0, \dots, x_{2n}\}$ \;
        $\Delta = \{(x_{2i-2},1,1\!-\!2t_i, x_{2i-1}), (x_{2(n-i)-1}, 1, -\!2t_i, x_{2(n - i)})\}_{i=1}^{n}$ \;
        \Return $(\Sigma, Q, T, \Delta, x_0, x_{2n})$ \;
    }
    \end{algorithm}


    \begin{algorithm}[H] \DontPrintSemicolon \SetKwProg{Fn}{}{}{}
    \Fn {$\underline{T((i, \Xund, r))} \smallskip$} {
        \lIf {$i = 0$} {
            \Return $\emptyset$
        }
        \lElseIf {$r = s \mid u \vee r = s \cdot u$} {
            \Return $\{i\} \cup T(s) \cup T(u)$
        }
        \lElseIf {$r = s^{n,m}$} {
            \Return $\{i\} \cup T(s)$
        }
        \lElse {
            \Return $\{i\}$
        }
    }
    \end{algorithm}


    \columnbreak


    \includegraphics[width=\linewidth]{img/tnfa_construction.pdf}


\end{multicols}
\vspace{-2em}
\caption{TNFA construction.}
\end{figure*}



\begin{figure}\label{fig_tnfa_example}
\includegraphics[width=\linewidth]{img/tnfa_example.pdf}
\vspace{-2em}
\caption{
    Example TNFA for RE $(a|\epsilon)^{0,3}((a^{0,\infty})|(\epsilon))$.
}
\end{figure}

\clearpage
\pagebreak


\begin{figure*}
\begin{multicols}{2}

    \newcommand \NOPASS {O\!F\!F}
    \newcommand \TOPSORT {T\!O\!P}
    \newcommand \LINEAR {L\!I\!N}
    \newcommand \INQUEUE {I\!N}
    \newcommand \OFFQUEUE {OUT}
    \newcommand \Xfalse {f\!al\!se}

    \setstretch{0.85}

    \begin{algorithm}[H] \DontPrintSemicolon \SetKwProg{Fn}{}{}{} \SetAlgoInsideSkip{medskip}
    \Fn {$\underline{closure \Xund gor1(X, Q, F, \Delta, P_1, P_2)} \smallskip$} {

        \Indm
        context: $C = (\; Q, F, \Delta, P_1, P_2$ \;
        \Indp
        $,\, topsort, linear : \text{stacks of states } q \in Q$ \;
        $,\, result  : Q \rightarrow \YC^Q \cup \{ \bot \}$ \;
        $,\, status  : Q \rightarrow \{ \NOPASS, \TOPSORT, \LINEAR \}$ \;
        $,\, indeg   : Q \rightarrow \YZ$                          \tcp{in-degree of state}
        $,\, active  : Q \rightarrow \YB$                          \tcp{true if state needs rescan}
        $,\, arcs    : Q \rightarrow 2^\Delta$                     \tcp{ordered set of outgoing transitions}
        $,\, next    : Q \rightarrow \YZ)$                         \tcp{index of current transition}
        \Indm
        \Indp

        \BlankLine
        \For {$q \in Q$} {
            $result(q) = \bot$ \;
            $status(q) = \NOPASS$ \;
%            $indeg(q)  = $ in-degree of $q$ in $\Delta$ \;
            $active(q) = \Xfalse$ \;
%            $arcs(q)   = \{ (q, \epsilon, \Xund, \Xund) \in \Delta \}$ \;
            $next(q)   = 1$ \;
        }

        \BlankLine
        \For {$x = (\Xund, q, \Xund, \Xund) \in X$ in inverse order of $precede_0$} {
            $result(q) = x$ \;
            $push(topsort, q)$
        }

        \BlankLine
        \While {$topsort$ is not empty} {

            \BlankLine
            \While {$topsort$ is not empty} {
                $q = pop(topsort)$ \;

                \If {$status(q) \neq \LINEAR$} {
                    $status(q) = \TOPSORT$ \;

                    \While {$true$} {
                        $p = next \Xund admissible \Xund arc(q, C)$ \;
                        \If {$p = \bot$} {
                            $status(q) = \LINEAR$ \;
                            $push(linear, q)$ \;
                            $break$
                        }
                        \ElseIf {$status(p) = \NOPASS$} {
                            $push(topsort, q)$ \;
                            $push(topsort, p)$ \;
                            $next(p) = 1$ \;
                            $break$
                        }
                        \lElse {$active(p) = true$}
                    }
                }
            }

            \BlankLine
            \While {$linear$ is not empty} {
                $q = pop(linear)$ \;

                \If {$active(q)$} {
                    $next(q) = 1$ \;
                    \While {$true$} {
                        $p = next \Xund admissible \Xund arc(q, C)$ \;
                        \lIf {$p = \bot$} {$break$}
                        \ElseIf {$status(p) = \NOPASS$} {
                            $push(topsort, p)$ \;
                            $next(p) = 1$ \;
                        }
                        \ElseIf {$status(p) = \LINEAR$} {
                            $active(p) = true$ \;
                        }
                    }
                }

                $status(q) = \NOPASS$ \;
                $active(q) = \Xfalse$ \;
            }
        }

%TRIE!!!!!!!
        \BlankLine
        \Return $\big\{ (\Xund, q, \Xund, \Xund) = result(q) \mid core(q, C) \}$
    }
    \end{algorithm}

    \begin{algorithm}[H] \DontPrintSemicolon \SetKwProg{Fn}{}{}{} \SetAlgoInsideSkip{medskip}
    \Fn {$\underline{core (q, C)} \smallskip$} {
        \tcp{is final or has outgoing transitions on symbols}
        \Return $q \in F \vee \exists (q, \alpha, \Xund, \Xund) \in \Delta^\Sigma$ \;
    }
    \end{algorithm}


    \columnbreak


    \begin{algorithm}[H] \DontPrintSemicolon \SetKwProg{Fn}{}{}{} \SetAlgoInsideSkip{medskip}
    \Fn {$\underline{closure \Xund gtop(X, Q, F, \Delta, P_1, P_2)} \smallskip$} {

        \Indm
        context: $C = (\; Q, F, \Delta, P_1, P_2$ \;
        \Indp
        $,\, queue : \text{priority queue of states } q \in Q$ \;
        $,\, result  : Q \rightarrow \YC^Q \cup \{ \bot \}$ \;
        $,\, status  : Q \rightarrow \{ \INQUEUE, \OFFQUEUE\}$     \;
        $,\, indeg   : Q \rightarrow \YZ$                          \tcp{in-degree of state}
        $,\, topord  : Q \rightarrow \YZ$                          \tcp{topological index of state}
        $,\, arcs    : Q \rightarrow 2^\Delta$                     \tcp{ordered set of outgoing transitions}
        $,\, next    : Q \rightarrow \YZ)$                         \tcp{index of current transition}
        \Indm
        \Indp

        \BlankLine
        \For {$q \in Q$} {
            $result(q) = \bot$ \;
            $status(q) = \OFFQUEUE$ \;
%            $indeg(q)  = $ in-degree of $q$ in $\Delta$ \;
%            $topord(q) = \text{ topological index of } q \text { in TNFA}$ \;
%            $arcs(q)   = \{ (q, \epsilon, \Xund, \Xund) \in \Delta \}$ \;
            $next(q)   = 1$ \;
        }

        \BlankLine
        \For {$x = (\Xund, q, \Xund, \Xund) \in X$} {
            $y = result(q)$ \;
            \If {$y = \bot \vee precede(x, y, C)$} {
                $result(q) = x$ \;
                \If {$status(q) \neq \INQUEUE$} {
                    $insert \Xund with \Xund priority(queue, q, topord(q))$ \;
                    $status(q) = \INQUEUE$ \;
                }
            }
        }

        \BlankLine
        \While {$queue$ is not empty} {

            $q = extract \Xund min(queue)$ \;
            $status(q) = \OFFQUEUE$ \;
            $next(q) = 1$ \;

            \While {$true$} {
                $p = next \Xund admissible \Xund arc(q, C)$ \;
                \lIf {$p = \bot$} {$break$}
                \ElseIf {$status(p) \neq \INQUEUE$} {
                    $insert \Xund with \Xund priority(queue, p, topord(p))$ \;
                    $status(p) = \INQUEUE$ \;
                }
            }
        }

%TRIE!!!!!!!
        \BlankLine
        \Return $\big\{ (\Xund, q, \Xund, \Xund) = result(q) \mid core(q, C) \}$
    }
    \end{algorithm}



    \begin{algorithm}[H] \DontPrintSemicolon \SetKwProg{Fn}{}{}{} \SetAlgoInsideSkip{medskip}
    \Fn {$\underline{next \Xund admissible \Xund arc (q, C)} \smallskip$} {
        $\{ a_1, \dots, a_n \} = arcs (q)$ \;
        $i = next (q)$ \;

        \While {$i < n$} {

            $(q, \epsilon, \tau, p) = a_i$ \;
            $next(q) = i = i + 1$ \;
            $x = (o, p, u \tau, t \tau)$, where $(o, q, u, t) = result(q)$ \;
            $y = result(p)$ \;

            \If {$y = \bot
                \vee indeg(p) < 2
                \vee precede(x, y, C)$} {
                $result(p) = x$ \;
                \Return $p$
            }
        }

        \Return $\bot$
    }
    \end{algorithm}


    \begin{algorithm}[H] \DontPrintSemicolon \SetKwProg{Fn}{}{}{} \SetAlgoInsideSkip{medskip}
    \Fn {$\underline{precede (x, y, C)} \smallskip$} {
        $(\Xund, \Xund, l) = precedence (x, y, P_1, P_2)$ \;
        \Return $l = -1$ %\tcp{true if x precedes y}
    }
    \end{algorithm}


    \begin{algorithm}[H] \DontPrintSemicolon \SetKwProg{Fn}{}{}{} \SetAlgoInsideSkip{medskip}
    \Fn {$\underline{precede_0 (x, y, C)} \smallskip$} {
        $(p,\Xund,\Xund,\Xund) = x, \; (q,\Xund,\Xund,\Xund) = y$ \;
        \Return $P_2[p][q] < 0$ \;
    }
    \end{algorithm}
\end{multicols}
\vspace{-2em}
\begin{center}
\caption{GOR1 and GTOP closure algorithms.
The definitions of $push$, $pop$, $insert \Xund with \Xund priority$, $extract \Xund min$ \\
$arcs$, $indeg$ and $topord$ are omitted for brevity.
%topological sorting of TNFA states is also left for the reader.
$\YC^Q = Q \times Q \times \YZ^* \times \YZ^*$ is the set of all configurations over $Q$.}
\end{center}
\end{figure*}


\clearpage
\pagebreak

\section{GOR1 correcness proof}

For a given RT $r$,
we say that PE $\alpha$ is \emph{minimal} if $\alpha = PE(t)$ for some minimal $t \in PT(r)$,
and we say that path $\pi$ in TNFA $F(r)$ is \emph{minimal} if $\pi$ induces a minimal PE.

GOR1 correctness proof consists of two parts.
First, we get rid of $\epsilon$-loops by showing that,
on one hand, minmal paths do not contain $\epsilon$-loops,
and on the other hand, GOR1 cancels all paths which contain $\epsilon$-loops.
Second, for paths without $\epsilon$-loops we show right distributivity of path comparison over path concatenation.
The proofs make use of the TNFA nested structure
and the fact that each sub-TNFA is has a unique entry and exit states.
TNFA construct for all possible types of RT are shown on the fugure below.



\begin{figure}\label{fig_gor1}
\includegraphics[width=\linewidth]{img/gor1.pdf}
\caption{
Sub-TNFA for individual sub-RT with submatch groups: \\
(a) -- union, (b) -- product, (c), (d) -- bounded repetition, (e), (f) -- unbounded repetition.
}
\end{figure}

    \begin{XLem}\label{gor1_path_containment}
    Let $r$ be a RE, $\pi = q_1 \overset {\alpha} {\rightsquigarrow} q_2$ a tagged path in TNFA $F(r)$,
    where $\alpha \neq \epsilon$,
    and $h = minh (\alpha)$ the minimal tag height on path $\pi$.
    The following statements are true:
    \begin{enumerate}
        \item There is a position $p$ of length $|p| = h$
            such that $\pi$ fully lies inside of subautomaton $F(r|_p)$.

        \item There no position $p$ of length $|p| > h$
            such that $\pi$ fully lies inside of subautomaton $F(r|_p)$.
    \end{enumerate}
    Proof.
    Obvious from TNFA construction.
    $\square$
    \end{XLem}




    \begin{XLem}\label{gor1_minpaths}
    Minimal paths do not contain tagged $\epsilon$-loops.
    \\
    Proof.

    Suppose, on the contrary, that $\pi$ is a minimal path in TNFA $F(r)$, and that $\pi$ contains at least one $\epsilon$-loop.
    Consider the \emph{last} $\epsilon$-loop in $\pi$:
    it can only come from sub-TNFA of the form $F\big( (i, \Xund, (i_1, \Xund, r_1)^{n,\infty}) \big)$ where $n \geq 0$,
    as this is the only looping TNFA construct.
    Let $w_n$ be the final state of sub-TNFA $F\big( (i_1, \Xund, r_1) \big)$
    as shown on figure \ref{fig_gor1} (e) -- (f).
    Then $\pi$ can be represented as
    $\pi = \pi_1 \pi_2 \pi_3$, where $\pi_2$ is the $\epsilon$-loop:
    $\pi_1 = q_0 \overset {u | \alpha} {\rightsquigarrow} w_n$ and
    $\pi_2 = w_n \overset {\epsilon | \beta} {\rightsquigarrow} w_n$ and
    $\pi_3 = w_n \overset {v | \gamma} {\rightsquigarrow} q_f$.
    Consider path $\pi' = \pi_1 \pi_3$ that is obtained from $\pi$ by removing $\pi_2$.
    It consumes the same input string $uv$ as $\pi$,
    therefore PE transduced by $\pi$ and $\pi'$ are comparable: $\alpha \beta \gamma, \alpha \gamma \in PE(r, uv)$.
    Let $j$ be the total number of repetitions through $F\big( (i_1, \Xund, r_1) \big)$,
    and let $i$ be the index of the $\epsilon$-loop repetition.

    First case: $i = j$.
    In this case fork of $\alpha \beta \gamma$ and $\alpha \gamma$ happens immediately after $(i-1)$-th repetition:
    %
    \begin{alignat*}{10}
        \alpha \beta \gamma &= x_0 \Xl_{h-1} \;&&\; \Xl_h x_1 \Xr_h \hdots \Xl_h x_{i-1} \Xr_h \;&&\big|\; \Xl_h x_{i} \Xr_h \;&&\; \Xr_{h-1} x_{j+1} \\[-0.5em]
        \alpha \gamma       &= x_0 \Xl_{h-1} \;&&\; \Xl_h x_1 \Xr_h \hdots \Xl_h x_{i-1} \Xr_h \;&&\big|\;                   \;&&\; \Xr_{h-1} x_{j+1}
    \end{alignat*}
    %
    It must be $\alpha \beta \gamma \sim \alpha \gamma$,
    because $minh (\beta) = h > h - 1 = minh (first (\gamma))$,
    so at the fork frame $k$ we have $\rho_k = \rho'_k \leq h - 1$.
    %
    Furthermore, it must be $\alpha \gamma \subset \alpha \beta \gamma$,
    because $first (\gamma) = \Xr < \Xl = first (\beta)$.

    Second case: $i < j$.
    In this case $(i + 1)$-th repetition cannot be an $\epsilon$-loop
    (because we assumed that $i$-th repetition is the \emph{last} $\epsilon$-loop),
    therefore
    fork of $\alpha \beta \gamma$ and $\alpha \gamma$ happens
    inside of $i$-th repetition of $\alpha \beta \gamma$
    and $(i + 1)$-th repetition of $\alpha \gamma$:
    %
    \begin{alignat*}{10}
        \alpha \beta \gamma &= x_0 \Xl_{h-1} \;&&\; \Xl_h x_1 \Xr_h \hdots \Xl_h x_{i-1} \Xr_h \Xl_h y_1 \;&&\big|\; y_2 \Xr_h \Xl_h x_{i+1} \Xr_h && \Xl_h x_{i+2} \Xr_h \hdots \Xl_h x_j \Xr_h \;&&\; \Xr_{h-1} x_{j+1} \\[-0.5em]
        \alpha \gamma       &= x_0 \Xl_{h-1} \;&&\; \Xl_h x_1 \Xr_h \hdots \Xl_h x_{i-1} \Xr_h \Xl_h y_1 \;&&\big|\; y_3 \Xr_h                     && \Xl_h x_{i+2} \Xr_h \hdots \Xl_h x_j \Xr_h \;&&\; \Xr_{h-1} x_{j+1}
    \end{alignat*}
    %
    In this case
    fork frame of $\alpha \beta \gamma$ contains $y_2 \Xr_h \Xl_h$ fragment, because $y_2$ is part of the $\epsilon$-loop.
    But the fork frame of $\alpha \gamma$ ends inside of $y_3$, because $(i+1)$-th repetiton is not an $\epsilon$-loop and must contain alphabet symbols.
    Therefore at the fork frame $k$ we have $\rho_k = h$ and $\rho'_k > h$.
    All subsequent frames $l > k$ are identical,
    so either $\rho_l = \rho'_l = h'$ (if $l$-th frame contains parentheses of height $h' \leq h$),
    or else $\rho_l = \rho_k$ and $\rho'_l = \rho'_k$.
    Consequently $\alpha \gamma \sqsubset \alpha \beta \gamma$.

    In both cases $\alpha \gamma < \alpha \beta \gamma$,
    which contradicts the fact that $\pi$ is a minimal path.
    $\square$
    \end{XLem}



    \begin{XLem}\label{gor1_loops}
    GOR1 discards paths with tagged $\epsilon$-loops.
    \\
    Proof.

    GOR1 finds non-looping paths before their looping counterparts,
    as it uses depth-first search to explore new paths and prunes ambiguous paths
    immediately after exploring transitions to the join state.
    So for each TNFA state, the first path to be found is a path without $\epsilon$-loops.
    We will show that once GOR1 has found a path without $\epsilon$-loops,
    it will never prefer a path with an $\epsilon$-loop
    (though of course it might prefer some other path without $\epsilon$-loops).

    The only TNFA construct that has a loop is unbounded repetition
    $F\big( (i, \Xund, (i_1, \Xund, r_1)^{n,\infty}) \big)$ where $n \geq 0$,
    shown on figure \ref{fig_gor1} (e) -- (f).
    Consider arbitrary path $\pi$ that contains
    $\epsilon$-loop through sub-TNFA $F\big( (i_1, \Xund, r_1) \big)$.
    %
    Let $q_1$ be the first state on $\pi$ that belongs to the $\epsilon$-loop.
    %
    Path $\pi$ can be represented as $\pi = \pi_1 \pi_2 \pi_3$, where
    $\pi_1 = q_0 \overset {u | \alpha} {\rightsquigarrow} q_1$ and
    $\pi_2 = q_1 \overset {\epsilon | \beta} {\rightsquigarrow} q_1$ and
    $\pi_3 = q_1 \overset {v | \gamma} {\rightsquigarrow} q_f$.
    %
    By the time GOR1 finds path $\pi_1 \pi_2$,
    it must have already found some other path $\pi'_1 = q_0 \overset {u | \alpha'} {\rightsquigarrow} q_1$ without $\epsilon$-loops.
    There are two possible cases: either $\alpha' = \alpha$, or $\alpha' < \alpha$.
    We will show that in both cases $\alpha' < \alpha \gamma$
    and consequently, GOR1 prefers the path without the $\epsilon$-loop.
    Let $k$ be the index of the last frame
    and $\big( (\rho_1, \hdots, \rho_k), (\rho'_1, \hdots, \rho'_k) \big) = traces (\alpha', \alpha \gamma)$.

    First case: $\alpha' = \alpha$.
    Because $\alpha$ is a proper prefix of $\alpha \gamma$,
    fork happens at the last frame and we have
    $\rho_k = lasth(\alpha)$ and
    $\rho'_k = min (lasth(\alpha), minh(\gamma))$.
    If $lasth(\alpha) > minh(\gamma)$, then $\rho_k > \rho'_k$ and $\alpha \sqsubset \alpha \gamma$.
    Otherwise $\rho_k = \rho'_k$ and $\alpha \sim \alpha \gamma$,
    and we have $first(\alpha \backslash \alpha \gamma) = \bot$ and $first(\alpha \gamma \backslash \alpha) \neq \bot$,
    therefore $\alpha \subset \alpha \gamma$.
    In both cases $\alpha < \alpha \gamma$.

    Second case: $\alpha' < \alpha$.
    Let $\big( (\sigma_1, \hdots, \sigma_k), (\sigma'_1, \hdots, \sigma'_k) \big) = traces (\alpha', \alpha)$.
    We have $\rho_k = \sigma_k$ and $\rho'_k = min (\sigma'_k, minh(\gamma)) \leq \sigma_k$.
    If $minh(\gamma) < \sigma'_k$ then $\rho_k > \rho'_k$ and $\alpha' \sqsubset \alpha \gamma$.
    Otherwise $\rho'_k = \sigma'_k$.
    If $\alpha' \sqsubset \alpha$ then $\alpha' \sqsubset \alpha \gamma$.
    Otherwise $\alpha' \sim \alpha$ and $\alpha' \subset \alpha$.
    None of $\alpha$ and $\alpha'$ is a proper prefix of the other,
    because otherwise the longer path has an $\epsilon$-loop through $q_1$, which contradicts our assumption about $\pi_1$ and $\pi'_1$.
    Therefore $first (\alpha' \backslash \alpha) = first (\alpha' \backslash \alpha \gamma)$
    and $first (\alpha \backslash \alpha') = first (\alpha \gamma \backslash \alpha')$.
    Consequently $\alpha' \subset \alpha \implies \alpha' \subset \alpha \gamma$.
    Thus $\alpha' < \alpha \gamma$.
    $\square$
    \end{XLem}





    \begin{XLem} \emph{(Right distributivity of path comparison over path concatenation for $\epsilon$-loop free paths.)}
    Let
    $\pi_\alpha = q_0 \overset {u | \alpha} {\rightsquigarrow} q_1$ and
    $\pi_\beta  = q_0 \overset {u | \beta}  {\rightsquigarrow} q_1$
    be ambiguous paths in TNFA $F(r)$
    and $\pi_\gamma = q_1 \overset {\epsilon | \gamma} {\rightsquigarrow} q_2$
    their common $\epsilon$-suffix,
    such that paths $\pi_\alpha$, $\pi_\beta$
    and the extended paths $\pi_\alpha \pi_\gamma$, $\pi_\beta \pi_\gamma$
    are all free from $\epsilon$-loops.
    Then $\alpha < \beta \implies \alpha \gamma < \beta \gamma$.
    \\
    Proof.

    Let $k = |u|$ be the number of frames in $\alpha$ and $\beta$.
    Let
    $\big( (\rho_1, \hdots, \rho_k),$ $(\rho'_1, \hdots, \rho'_k) \big) = traces (\alpha, \beta)$ and
    $\big( (\sigma_1, \hdots, \sigma_k),$ $(\sigma'_1, \hdots, \sigma'_k) \big) = traces (\alpha \gamma, \beta \gamma)$.
    Obviously for frames $i < k$ we have $\rho_i = \sigma_i$ and $\rho'_i = \sigma'_i$,
    and for the last frame $k$ we have
    $\sigma_k = min (\rho_k, minh (\gamma))$ and
    $\sigma'_k = min (\rho'_k, minh (\gamma))$.
    Consider two possible cases.

    First case: $\alpha \sim \beta \wedge \alpha \subset \beta$.
    %
    We show that $\alpha \gamma \sim \beta \gamma \wedge \alpha \gamma \subset \beta \gamma$.
    %
    We have $\rho_i = \rho'_i \; \forall i$, therefore
    $\sigma_i = \sigma'_i \; \forall i$ and consequently $\alpha \gamma \sim \beta \gamma$.
    Let
    $x = first (\alpha \backslash \beta)$,
    $y = first (\beta \backslash \alpha)$,
    $x' = first (\alpha \backslash \beta \gamma)$ and
    $y' = first (\beta \backslash \alpha \gamma)$.
    None of $\pi_\alpha$ and $\pi_\beta$ is a proper prefix of another,
    otherwise the longer path must contain $\epsilon$-loop through $q_1$
    (because $\alpha$ and $\beta$ have the same number of frames).
    Consequently $x = x'$ and $y = y'$, and we have
    $\alpha \subset \beta$
    $\implies$
    $x < y$
    $\implies$
    $x' < y'$
    $\implies$
    $\alpha \gamma \subset \beta \gamma$.

    Second case: $\alpha \sqsubset \beta$.
    We show that $\alpha \gamma \sqsubset \beta \gamma$.
    %
    If $\rho_k = \rho'_k$ then $\sigma_k = \sigma'_k$
    and obviously $\alpha \gamma \sqsubset \beta \gamma$.
    Else it must be $\rho_k > \rho'_k$.
    In this case, if $minh (\gamma) > \rho'_k$, then $\sigma_k > \sigma'_k$ and again $\alpha \gamma \sqsubset \beta \gamma$.
    Else $minh (\gamma) \leq \rho'_k$ and $\sigma_k = \sigma'_k$.
    In this case, if $k > 1$ and $\rho_{k-1} > \rho'_{k-1}$ then again $\alpha \gamma \sqsubset \beta \gamma$.
    %
    In other words, the only possible case when $\gamma$ can change comparison result is
    when at the last frame we have $\rho_k > \rho'_k$,
    the appended suffix $\gamma$ contains parentheses with low height $minh (\gamma) \leq \rho'_k$
    (so that $\sigma_k = \sigma'_k$),
    and the previous frame doesn't exist
    or compares differently from the last frame: $k = 1$ or $\rho_{k-1} \leq \rho'_{k-1}$.
    We show that in this case the extended path $\pi_\beta \pi_\gamma$ must contain $\epsilon$-loop,
    which contradicts to the lemma condiitons.

    Consider the fragments of paths $\pi_\alpha$ and $\pi_\beta$ from fork to join,
    including (if it exists) the $\epsilon$-transition to the fork state:
    $\pi_\alpha' = q_2 \overset {u | \alpha'} {\rightsquigarrow} q_1$ and
    $\pi_\beta' = q_2 \overset {u | \beta'} {\rightsquigarrow} q_1$.
    We know that $minh (\alpha') = \rho_k$.
%    (because $\rho_k$ is set to the minimal parenthesis height on the path from fork to join).
    Therefore by lemma \ref{gor1_path_containment}
    we know that $\pi_\alpha'$ is contained in a subautomaton $f$ of height $\rho_k$.
    Likewise we know that $\pi_\beta'$ is not contained in $f$, because $minh (\beta') = \rho'_k < \rho_k$.
    %
    Let $\pi_\beta''$ be the part of $\pi_\beta'$ containing the last $k$-th frame,
    and note the following:
    \begin{enumerate}
        \item[(a)] the start state of $\pi_\beta''$ must be contained in $f$
            (because by our assumption
            either $k = 1$ and then start state of $\pi_\beta''$ is the fork state,
            or $\rho_{k-1} \leq \rho'_{k-1}$ which implies $\rho'_{k-1} \geq \rho_k$
            and then all but the last frames of $\pi_\beta'$ must be contained in $f$)
        \item[(b)] $\pi$ cannot be contained in $f$
            (because by our assumption $\rho_k > \rho'_k$)
        \item[(c)] the end state of $\pi_\beta''$ is contained in $f$
            (because it's the join state $q_1$ of $\pi_\alpha'$ and $\pi_\beta'$)
        \item[(d)] $\pi_\gamma$ is not contained in $f$
            (because by our assumption $minh (\gamma) \leq \rho'_k$ and consequently $minh (\gamma) < \rho_k$)
    \end{enumerate}
    %
    Put together, items (a) - (d) mean that the $\epsilon$-path $\pi_\beta'' \pi_\gamma$
    first leaves subautomaton $f$, then re-enters $f$, and then leaves $f$ second time.
    Because $f$ has a unique exit state, this means that $\pi_\beta'' \pi_\gamma$ contains $\epsilon$-loop
    through the exit state of $f$, which contradicts lemma conditions.
    (Effectively it means that $\pi_\beta \pi_\gamma$ is non-minimal and would be discarded by GOR1 anyway.)
%   Note that $\pi_\beta'$ itself does not necessarily contain $\epsilon$-loop.
    %
    $\square$
    \end{XLem}




\section{Matching algorithm}

The final algorithm, complexity estimates.

\section{Conclusions}

\FloatBarrier
\pagebreak

\section*{Appendix}

\subsection*{Proof of Theorem \ref{theorem_order_on_IPTs}}

    \begin{XLem}\label{lemma_ptorder_antisymmetry}
    The order on IPTs is antisymmetric: if $t < s$, then $s \not< t$.
    \\
    Proof.

    Suppose, on the contrary, that $t <_p s$ and $s <_q t$ for some $p$, $q$.
    Without loss of generality let $p \leq q$.
    On one hand $t <_p s$ implies $\|t\|_p > \|s\|_p$.
    On the other hand $s <_q t$ implies $\|t\|_p \leq \|s\|_p$.
    Contradicting the assumption.
    $\square$
    \end{XLem}

    \begin{XLem}\label{lemma_ptorder_transitivity}
    The order on IPTs is transitive: if $t < s$ and $s < u$, then $t < u$.
    \\
    Proof.

    Let $t <_p s$ and $s <_q u$ for some positions $p$, $q$, and let $r = min (p, q)$.
    \\[-1em]

    First, we show that $\|t\|_r > \|u\|_r$.
    If $p \leq q$, we have $\|t\|_p > \|s\|_p$ (implied by $t <_p s$)
    and $\|s\|_p \geq \|u\|_p$ (implied by conjunction $s <_q u \wedge p \leq q$),
    therefore $\|t\|_p > \|u\|_p$.
    Otherwise $p > q$, we have $\|s\|_q > \|u\|_q$ (implied by $s <_q u$)
    and $\|t\|_q = \|s\|_q$ (implied by conjunction $t <_p s \wedge q < p$),
    therefore $\|t\|_q > \|u\|_q$.
    \\[-1em]

    Second, we show that $\forall r' < r$ it holds that $\|t\|_{r'} = \|u\|_{r'}$.
    We have $\|t\|_{r'} = \|s\|_{r'}$ (implied by conjunction $t <_p s \wedge r' < p$)
    and $\|s\|_{r'} = \|u\|_{r'}$ (implied by conjunction $s <_q u \wedge r' < q$),
    therefore $\|t\|_{r'} = \|u\|_{r'}$.
    $\square$
    \end{XLem}

    \begin{XLem}\label{incomparability_equivdef}
    $t \sim s \Leftrightarrow \; \forall p : \|t\|_p = \|s\|_p$.
    \\
    Proof.

    $\Rightarrow$. %First, we show $t \sim s \Rightarrow \forall p : \|t\|_p = \|s\|_p$.
    Suppose, on the contrary, that $\exists p = min \{ q \mid \|t\|_q \neq \|s\|_q \}$,
    then either $t <_p s$ (if $\|t\|_p > \|s\|_p$), or $s <_p t$ (if $\|t\|_p < \|s\|_p$).
    Both cases contradict $t \sim s$.
    \\[-1em]

    $\Leftarrow$.
    $\forall p : \|t\|_p = \|s\|_p$ implies
    $\nexists p : t <_p s$ and $\nexists q : s <_q t$,
    which implies $t \sim s$.
    $\square$
    \end{XLem}

    \begin{XLem}\label{lemma_ptorder_transitivity_of_incomparability}
    Incomparability relation on parse trees is transitive: if $t \sim s$ and $s \sim u$, then $t \sim u$.
    \\
    Proof.

    By lemma \ref{incomparability_equivdef} we have
    $t \sim s \Rightarrow \forall p : \|t\|_p = \|s\|_p$ and
    $s \sim u \Rightarrow \forall p : \|s\|_p = \|u\|_p$,
    therefore by lemma \ref{incomparability_equivdef} $\forall p : \|t\|_p = \|u\|_p \Rightarrow t \sim u$.
    $\square$
    \end{XLem}

The proof of theorem \ref{theorem_order_on_IPTs}
follows from
the lemma \ref{lemma_ptorder_antisymmetry},
the lemma \ref{lemma_ptorder_transitivity} and
the lemma \ref{lemma_ptorder_transitivity_of_incomparability}.


\subsection*{Proof of Theorem \ref{theorem_order_compat}}

First, we prove an auxilary lemma \ref{lemma_subtrees} which
shows that comparison of sub-IPT is justified
if the s-norms at all preceding submatch positions are equal.

    \begin{XLem}\label{lemma_subtrees}
    If $t, s \in \IPT(r, w)$ and $\exists p \in Sub(t) \cup Sub(s)$ such that $\snorm{t}{q} = \snorm{s}{q} \; \forall q \leq p$,
    then $\exists \widetilde{r}, \widetilde{w} : t|_p, s|_p \in \IPT(\widetilde{r}, \widetilde{w})$.
    \\
    Proof.
    By induction on position $p$.
    \\[-1em]

    Induction basis: the case of $p = \Lambda$ is trivial: let $\widetilde{r} = r$, $\widetilde{w} = w$.
    \\[-1em]

    Induction step: we have $|p| > 0$, let $p = p'.i$, where $i \in \YN$.
    Let $t' = t|_{p'} = T(t_1, \dots, t_n)$,
        $s' = s|_{p'} = T(s_1, \dots, s_m)$.
    By induction hypothesis $\exists r', w' : t', s' \in \IPT(r', w')$,
    where $w' = str(t_1) \dots str(t_n) = str(s_1) \dots str(s_m)$.
    \\[-1em]

    Next, we show that $str(t_i) = str(s_i)$.
    It must be that $i \in Sub(s') \cap Sub(t')$,
    otherwise only one of $\|t'\|_i$, $\|s'\|_i$ is $\infty$,
    which contradicts lemma condiiton $\|t\|_p = \|s\|_p$.
    Consider position $j \leq i$.
    Because the set of submatch positions contains siblings, we have $j \in Sub(s') \cap Sub(t')$.
    Consequently, $\|t'\|_j = |str(t_j)|$ and $\|s\|_j = |str(s_j)|$.
    By lemma condition we have $\|t\|_{p'.j} = \|s\|_{p'.j}$,
    therefore $\|t'\|_j = \|s'\|_j$,
    therefore $|str(t_j)| = |str(s_j)|$.
    Because $str(t_1) \dots str(t_n) = str(s_1) \dots str(s_m)$,
    we have $str(t_i) = str(s_i)$.
    \\[-1em]

    Now, let $\widetilde{w} = str(t_i)$.
    If $r' = r_1|r_2$ or $r' = r_1 r_2$, let $\widetilde{r} = r_i$.
    Otherwise, $r' = r_1^{k,l}$, let $\widetilde{r} = r_1$.
    $\square$
    \end{XLem}


    Proof of theorem \ref{theorem_order_compat}.
    \\[-1em]

    Consider any $t \in T_{min}$.
    For each position $p \in Sub(t)$, which is not itself a prefix of another position in $Sub(t)$,
    consider subtree $t' = t|_p$.
    It is an IPT for some sub-IRE $r'$ and substring $w'$: $t' \in \IPT(r', w')$.
    Let $t''$ be the $<$-minimal tree in $\IPT(r', w')$ and substitute $t'$ with $t''$ in $t$.
    (Note that substitutions are independent and can be performed in any order.)
    Let $u$ be the tree resulting from all such substitutions.
    By lemma \ref{incomparability_equivdef} we have $u \sim t$
    (because substitutions preserve the s-norm of subtrees at positions in $Sub(t)$),
    and so $u \in T_{min}$.
    We will show that $u = t_{min}$.
    \\[-1em]

    Suppose, on the contrary, that $u \neq t_{min}$.
    %
    Then we have $t_{min} <_p u$ for some non-submatch decision position $p$.
    Let $p = p'.p''$, where $p'$ is the longest prefix of $p$ that is a submatch position: $p' \in Sub(u) \cup Sub(t_{min})$.
    \\[-1em]

    It must be that for all submatch positions $q' < p'$ we have $\snorm{u}{q'} = \snorm{t_{min}}{q'}$,
    because $u \in T_{min}$ and thus either $u \sim t_{min}$,
    or $u \prec_q t_{min}$ for some $q \in Sub(u) \cup Sub(t_{min})$
    (in which case it must be $q > p$, because $u \prec_q t_{min}$ implies $\snorm{u}{q} > \snorm{t_{min}}{q}$,
    which in turn implies $\pnorm{u}{q} > \pnorm{t_{min}}{q}$,
    which contradicts $t_{min} <_p u$ if $q \leq p$).
    \\[-1em]

    Therefore by lemma \ref{lemma_subtrees} we have $\exists r', w' : u|_{p'}, t_{min}|_{p'} \in \IPT(r', w')$.
    On one hand, $t_{min} <_{p'.p''} u$ implies $t_{min}|_{p'} <_{p''} u|_{p'}$.
    But on the other hand, $p' \in Sub(u)$ and $p'$ is not itself a prefix of another position in $Sub(u)$,
    therefore $u|_{p'}$ is $<$-minimal by construction of $u$.
    Contradiction.
%    
%    %
%    On one hand, $u <_q \widetilde{s}$ for some submatch position $q$ (because $u \in P_{min}$).
%    On the other hand, $s \lessdot_p \widetilde{u}$ for some non-submatch position $p < q$ (because $s$ is $\lessdot$-minimal).
%    %
%    Let $p = p'.p''$, where $p'$ is the longest prefix of $p$ in $Sub(\widetilde{s}) \cup Sub(u)$.
%    It must be $\|u\|_{q'} = \|\widetilde{s}\|_{q'} \forall q' \leq p'$ (because $p' < q$ and $u <_q \widetilde{s}$),
%    and $p' \in Sub(u)$ (otherwise $\|u\|_{p'} = \infty \neq \|\widetilde{s}\|_{p'}$).
%    %
%    Now, by lemma \ref{lemma_subtrees} we have $\exists r', w' : u|_{p'}, \widetilde{s}|_{p'} \in PT(r', w')$,
%    therefore $s \lessdot_{p'.p''} u$ implies $s|_{p'} \lessdot_{p''} \widetilde{u}|_{p'}$.
%    But $p' \in Sub(u)$ and $p'$ is not itself a prefix of another position in $Sub(u)$,
%    therefore $\widetilde{u}|_{p'}$ is $\lessdot$-minimal by construction of $u$.
%    Contradiction.
    $\square$


\subsection*{Proof of Theorem \ref{theorem_order_on_pe_same_as_on_pt}}

    \begin{XLem}\label{lemma_pe_order_antisymm}
    The longest-leftmost-precedence relation $<$ is antisymmetric:
    if $\alpha < \beta$, then $\beta \not< \alpha$.
    \\
    Proof.
    Suppose, on the contrary, that $\alpha < \beta$ and $\beta < \alpha$.
    Let $\big( (\rho_0, \dots, \rho_n), (\rho'_0, \dots, \rho'_n) \big) = traces(\alpha, \beta)$.

    \medskip

    If $\exists i = max \{j \mid \rho_j \neq \rho'_j \}$, then
    $\alpha < \beta \implies \alpha \sqsubset \beta \implies \rho_i > \rho'_i$, but
    $\beta < \alpha \implies \beta \sqsubset \alpha \implies \rho'_i > \rho_i$. Contradiction.

    \medskip

    Otherwise $\rho_i = \rho'_i \; \forall i$, then
    $\alpha < \beta \implies \alpha \sim \beta \wedge \alpha \subset \beta$ and
    $\beta < \alpha \implies \beta \sim \alpha \wedge \beta \subset \alpha$.
    Let
    $x = first (\alpha \backslash \beta)$,
    $y = first (\beta \backslash \alpha)$, then
    $\alpha \subset \beta \implies x < y$, but
    $\beta \subset \alpha \implies y < x$. Contradiction.
    $\square$
    \end{XLem}


    \begin{XLem}\label{lemma_pe_equiv}
    Let $s, t \in PT(r, w)$.
    If $s \sim t$, then $\Phi_{h}(s) = \Phi_{h}(t) \; \forall h$.
    \\
    Proof.
    By induction on the height of $r$.

    \medskip

    Induction basis.
    For RT of height $1$ we have
    $| PT(r, w) | \leq 1 \; \forall w$,
    therefore $s = t$ and $\Phi_{h}(s) = \Phi_{h}(t)$.

    \medskip

    Induction step.
    We have
    $s = T^{d} (s_1, \dots, s_n)$ and
    $t = T^{d} (t_1, \dots, t_m)$.
    If $d = 0$, then $\Phi_{h}(s) = str(s) = w = str(t) = \Phi_{h}(t)$.
    Otherwise $d \neq 0$.
    By lemma \ref{incomparability_equivdef} we have $s \sim t \Rightarrow \forall p: \|s\|_p = \|t\|_p$.
    This implies $n = m$ (otherwise the norm of subtree at position $min(n,m)+1$ is $\infty$ for only one of $s$, $t$).
    Therefore
    $\Phi_{h}(s) = \Xl_{h+1} \Phi_{h+1}(s_1), \dots, \Phi_{h+1}(s_n) \Xr_h$ and
    $\Phi_{h}(t) = \Xl_{h+1} \Phi_{h+1}(t_1), \dots, \Phi_{h+1}(t_n) \Xr_h$.
%    Consider any $i \leq n$.
    It suffices to show that $\forall i \leq n: \Phi_{h+1}(s_i) = \Phi_{h+1}(t_i)$.
    We have $\forall p: \|s_i\|_p = \|t_i\|_p$ (implied by $\forall p: \|s\|_p = \|t\|_p$),
    therefore by lemma \ref{incomparability_equivdef} we have $s_i \sim t_i$,
    and by lemma \ref{lemma_subtrees} $\exists r', w': s_i, t_i \in PT(r', w')$,
    where the height of $r'$ is less than the height of $r$.
    By induction hypothesis $\Phi_{h+1}(s_i) = \Phi_{h+1}(t_i)$.
    $\square$
    \end{XLem}


    \begin{XLem}\label{lemma_pe_less_1}
    Let $s, t \in PT(r, w)$.
    If $s <_p t$ and $|p| = 1$, then $\Phi_{h}(s) < \Phi_{h}(t) \; \forall h$.
    \\
    Proof.

    By lemma conditions $|p| = 1$, which implies that $s$ and $t$ are compound PT
    $s = T^{d} (s_1, \dots, s_n)$ and 
    $t = T^{d} (t_1, \dots, t_m)$, where
    $d \neq 0$
    (because $\Lambda$ is a prefix of decision position $p$).
    Therefore $\Phi_{h}(s)$, $\Phi_{h}(t)$ can be represented as follows,
    where $k$ is the number of frames and $j$ is the fork:
    \begin{alignat*}{7}
        \Phi_{h}(s) &\;=\; \Xl_{h+1} &&\Phi_{h+1}(s_1) &&\dots &&\Phi_{h+1}(s_n) \Xr_h
            &&\;=\; \beta_0 a_1 \dots a_j \beta_j &&\;\big|\; && \gamma_j a_{j + 1} \dots a_k \gamma_k \\[-0.5em]
        \Phi_{h}(t) &\;=\; \Xl_{h+1} &&\Phi_{h+1}(t_1) &&\dots &&\Phi_{h+1}(t_m) \Xr_h
            &&\;=\; \beta_0 a_1 \dots a_j \beta_j &&\;\big|\; && \delta_j a_{j + 1} \dots a_k \delta_k
    \end{alignat*}
%
    By lemma conditions $|p| = 1$, therefore $p \in \YN$.
    Consider any $i \in \YN$ such that $i < p$.
    By lemma conditions $s <_p t$, which means
    $\|s\|_p > \|t\|_p \wedge \|s\|_q = \|t\|_q \;\forall q < p$.
    In particular $\|s_i\|_q = \|t_i\|_q \;\forall q$,
    therefore by lemma \ref{incomparability_equivdef} $s_i \sim t_i$
    and by lemma \ref{lemma_pe_equiv} we have $\Phi(s_i) = \Phi(t_i)$.
    Let $traces (\Phi_{h}(s), \Phi_{h}(t)) = \big( (\rho_0, \dots, \rho_k), (\rho'_0, \dots, \rho'_k) \big)$
    and consider the following cases.

    \medskip

    First case:
    $\infty = \|s_p\| > \|t_p\|$.
    In this case $s|_p$ does not exist
    (because $p$ corresponds to a submatch position in $r$,
    therefore $p \in Pos(s)$ implies $p \in Sub(s)$,
    which contradicts $\|s_p\| = \infty$).
    Fork happens immediately after $\Phi_{h+1}(s_{p-1})$, $\Phi_{h+1}(t_{p-1})$:
    \begin{alignat*}{7}
        \Phi_{h}(s) &\;=\; \Xl_{h+1} &&\Phi_{h+1}(s_1) &&\dots &&\Phi_{h+1}(s_{p-1})
            &&\;\big|\; \Xr_{h}         &&      && \\[-0.5em]
        \Phi_{h}(t) &\;=\; \Xl_{h+1} &&\Phi_{h+1}(t_1) &&\dots &&\Phi_{h+1}(t_{p-1})
            &&\;\big|\; \Phi_{h+1}(t_p) &&\dots &&\Phi_{h+1}(t_m) \Xr_{h}
    \end{alignat*}
    %
    In this case fork frame is the last frame: $j = k$, and therefore $\rho_j = \rho'_j = h$
    (because $\gamma_j$ and $\delta_j$ contain the closing parenthesis $\Xr_{h}$).
    For all $i < j$ we have $\rho_i = \rho'_i = -1$, therefore $\Phi_{h}(s) \sim \Phi_{h}(t)$.
    Furthermore, $first(\gamma_j)$ is $\Xr$ and $first(\delta_j)$ is one of $\Xl$ and $\Xm$,
    therefore $\Phi_{h}(s) \subset \Phi_{h}(t)$.
    Consequently $\Phi_{h}(s) < \Phi_{h}(t)$.

    \medskip

    Second case: $\infty > \|s_p\| > \|t_p\| = -1$.
    In this case both $s_p$ and $t_p$ exist,
    $s_p$ is not $\varnothing$ and $t_p$ is $\varnothing$,
    and fork happens immediately after $\Phi_{h+1}(s_{p-1})$, $\Phi_{h+1}(t_{p-1})$:
    \begin{alignat*}{8}
        \Phi_{h}(s) &\;=\; \Xl_{h+1} &&\Phi_{h+1}(s_1) &&\dots &&\Phi_{h+1}(s_{p-1})
            &&\;\big|\; \Xl_{h+1} \; x \; \Xr_{h+1} \; &&\Phi_{h+1}(s_{p+1}) &&\dots &&\Phi_{h+1}(s_n) \Xr_{h} \\[-0.5em]
        \Phi_{h}(t) &\;=\; \Xl_{h+1} &&\Phi_{h+1}(t_1) &&\dots &&\Phi_{h+1}(t_{p-1})
            &&\;\big|\; \Xm_{h+1} \;\;\;\;\;\;         &&\Phi_{h+1}(t_{p+1}) &&\dots &&\Phi_{h+1}(t_m) \Xr_{h}
    \end{alignat*}
    %
    If $j$-th frame is the last, we have $\rho_j = \rho'_j = h$ like in the first case.
    Otherwise we have $\rho_j = \rho'_j = h + 1$,
    because $minh(\gamma_j)$, $minh(\delta_j) \geq h + 1$
    and $lasth (\beta_j) = h + 1$
    (because if $p = 1$ then $\beta_j = \Xl_{h+1}$, otherwise
    $s_{p-1}$ exists and the last parenthesis in $\beta_j$
    is last parenthesis of $\Phi_{h+1}(s_{p-1})$, which is either $\Xr_{h+1}$ or $\Xm_{h+1}$).
    For subsequent frames $i$ such that $j < i < k$ we have $\rho_i = \rho'_i = h + 1$
    (because $minh(\gamma_j)$, $minh(\delta_j) \geq h + 1$),
    and for the last pair of frames we have $\rho_k = \rho'_k = h$.
    So in this case again $\Phi_{h}(s) \sim \Phi_{h}(t)$.
    Furthermore, $first (\gamma_j) = \Xl < \Xm = first (\delta_j)$, therefore $\Phi_{h}(s) \subset \Phi_{h}(t)$
    and $\Phi_{h}(s) < \Phi_{h}(t)$.

    \medskip

    Third case: $\infty > \|s_p\| > \|t_p\| \geq 0$.
    In this case both $s_p$ and $t_p$ exist and none of them is $\varnothing$,
    and fork happens somewhere after the opening parenthesis $\Xl$
    and before the closing parenthesis $\Xr$ in $\Phi_{h}(s_p)$, $\Phi_{h}(t_p)$:
    \begin{alignat*}{9}
        \Phi_{h}(s) &\;=\; \Xl_{h+1} &&\Phi_{h+1}(s_1) &&\dots &&\Phi_{h+1}(s_{p-1}) &&\; \Xl_{h+2} \; x
            &&\;\big|\; y \; \Xr_{h+1} \; &&\Phi_{h+1}(s_{p+1}) &&\dots &&\Phi_{h+1}(s_n) \Xr_{h} \\[-0.5em]
        \Phi_{h}(t) &\;=\; \Xl_{h+1} &&\Phi_{h+1}(t_1) &&\dots &&\Phi_{h+1}(t_{p-1}) &&\; \Xl_{h+2} \; x
            &&\;\big|\; z \; \Xr_{h+1} \; &&\Phi_{h+1}(t_{p+1}) &&\dots &&\Phi_{h+1}(t_m) \Xr_{h}
    \end{alignat*}
    %
    Let $l$ be an index such that the frame $\delta_l$ contains the closing parenthesis $\Xr_{h+1}$ of $\Phi_{h+1}(t_p)$.
    It must be $l \geq j$ (equality is possible due to non-fully parenthesized expressions,
    as in the example $(a|aa)^{0,\infty}$ shown on figure \ref{fig_pe3}).
    Because $\|s_p\| > \|t_p\|$,
    the closing parenthesis $\Xr_{h+1}$ of $\Phi_{h+1}(s_p)$ is not contained in $\gamma_{l}$,
    and $l$-th frame is not the last one.
    Therefore $minh (\gamma_l) \geq h+2$ and $minh (\delta_l) = h+1$.
    Furthermore, $minh(x)$, $minh(y)$, $minh(z) \geq h + 2$,
    therefore $lasth(\beta_j) \geq h+2$ and
    for all frames $j \leq i < l$ (if such $i$ exist) we have $\rho_i, \rho'_i \geq h+2$
    (note that it might be $\rho_i < \rho'_i$).
    For the $l$-th frame $\rho_l \geq h+2 > h+1 = \rho'_l$.
    For subsequent frames $\gamma_i$, $\delta_i$ such that $l < i < k$ we have
    $minh(\gamma_i)$, $minh(\delta_i) \geq h + 1$,
    therefore $\rho_i \geq h+1 = \rho'_i$.
    For the last pair of frames $\rho_k = \rho'_k = h$.
    Therefore in this case $\Phi_{h}(s) \sqsubset \Phi_{h}(t)$,
    which implies $\Phi_{h}(s) < \Phi_{h}(t)$.
    $\square$
    \end{XLem}


    \begin{XLem}\label{lemma_pe_less}
    Let $s, t \in PT(r, w)$.
    If $s <_p t$, then $\Phi_{h}(s) < \Phi_{h}(t) \; \forall h$.
    \\
    Proof.
    By induction on the length of $p$.

    \medskip

    Induction basis for $|p| = 1$ is given by lemma \ref{lemma_pe_less_1}.

    \medskip

    Induction step.
    Let $|p| \geq 2$, then $s$ and $t$ are compound PT
    $s = T^{d} (s_1, \dots, s_n)$ and
    $t = T^{d} (t_1, \dots, t_m)$, where
    $d \neq 0$ (because $\Lambda$ is a prefix of decision position $p$).
    %
    Furthermore, let $p = p'.p''$, where $p' \in \YN$.
    Subtrees $s' = s_{p'}$ and $t' = t_{p'}$ exist, because $p'$ a proper prefix of decision position $p$,
    and they also must be compount PT
    $s' = T^{d'} (s'_1, \dots, s'_{n'})$ and
    $t' = T^{d'} (t'_1, \dots, t'_{m'})$,
    because $|p''| > 0$, and it must be
    $d' \neq 0$ (because $p'$ is a prefix of decision position $p$).
    %
    For subtrees $s_i$ and $t_i$ where $i < p'$ we have
    $\|s_i\|_q = \|t_i\|_q \;\forall q$ (implied by $s <_p t$),
    therefore by lemma \ref{incomparability_equivdef}
    $s_i \sim t_i$, and by lemma \ref{lemma_pe_equiv} we have $\Phi_{h+1}(s_i) = \Phi_{h+1}(t_i)$.
    %
    Therefore $\Phi_{h}(s)$, $\Phi_{h}(t)$ can be represented as follows:
    \begin{alignat*}{9}
        \Phi_{h}(s)
            \;&=
                \;&& \Xl_{h+1} \Phi_{h+1}(s_1) \dots \Phi_{h+1}(s_{p'-1})
                \;&& \overbrace {\Xl_{h+2} \Phi_{h+2}(s'_1) \dots \Phi_{h+2}(s'_{n'}) \Xr_{h+1}}^{\Phi_{h+1}(s')}
                \;&& \Phi_{h+1}(s_{p'+1}) \Phi_{h+1}(s_n) \Xr_{h}
                \\
        \Phi_{h}(t)
            \;&=
                \;&& \Xl_{h+1} \Phi_{h+1}(t_1) \dots \Phi_{h+1}(t_{p'-1})
                \;&& \underbrace {\Xl_{h+2} \Phi_{h+2}(t'_1) \dots \Phi_{h+2}(t'_{m'}) \Xr_{h+1}}_{\Phi_{h+1}(t')}
                \;&& \Phi_{h+1}(t_{p'+1}) \Phi_{h+1}(t_m) \Xr_{h}
    \end{alignat*}

    We have $\|s\|_q = \|t\|_q \;\forall q < p'$ (implied by $s <_p t$),
    therefore by lemma \ref{lemma_subtrees} $\exists r', w' : s', t' \in PT(r', w')$.
    Moreover, $s' <_{p''} t'$ and $|p''| < |p|$, therefore by induction hypothesis $\Phi_{p+1}(s') < \Phi_{p+1}(t')$.
    %
    On the other hand, if $j$ is the fork and $f \leq j \leq k$ then
    $\Phi_{h}(s)$, $\Phi_{h}(t)$ can be represented as:
    \begin{alignat*}{9}
        \Phi_{h}(s)
            \;&=
                \;&& \beta_0 a_1 \dots a_f \beta_f^1
                \;&& \overbrace {\beta_f^2  a_{f+1} \dots a_j \beta_j \;\big|\; \gamma_j a_{j+1} \dots a_k \gamma_k^1}^{\Phi_{h+1}(s')}
                \;&& \gamma_k^2 a_{k+1} \dots a_l \gamma_l
                \\[-0.5em]
        \Phi_{h}(t)
            \;&=
                \;&& \beta_0 a_1 \dots a_f \beta_f^1
                \;&& \underbrace {\beta_f^2  a_{f+1} \dots a_j \beta_j \;\big|\; \delta_j a_{j+1} \dots a_k \delta_k^1}_{\Phi_{h+1}(t')}
                \;&& \delta_k^2 a_{k+1} \dots a_l \delta_l
    \end{alignat*}

%    \begin{alignat*}{9}
%        \Phi_{h}(s)
%            \;&=
%                \;&&\overbrace  {\Xl_{h+1} \Phi_{h+1}(s_1) \dots \Phi_{h+1}(s_{p'-1})}
%                    ^{\beta_0 a_1 \dots a_i \beta_i^1}
%                \;&&\overbrace  {\Xl_{h+2} \Phi_{h+2}(s'_1) \dots \Phi_{h+2}(s'_{n'}) \Xr_{h+1}}
%                    ^{\beta_i^2  a_{i+1} \dots a_j \beta_j \;\big|\; \gamma_j a_{j+1} \dots a_k \gamma_k^1}
%                \;&&\overbrace  {\Phi_{h+1}(s_{p'+1}) \Phi_{h+1}(s_n) \Xr_{h}}
%                    ^{\gamma_k^2 a_{k+1} \dots a_l \gamma_l}
%                \\
%        \Phi_{h}(t)
%            \;&=
%                \;&&\underbrace {\Xl_{h+1} \Phi_{h+1}(t_1) \dots \Phi_{h+1}(t_{p'-1})}
%                    _{\beta_0 a_1 \dots a_i \beta_i^1}
%                \;&&\underbrace {\Xl_{h+2} \Phi_{h+2}(t'_1) \dots \Phi_{h+2}(t'_{m'}) \Xr_{h+1}}
%                    _{\beta_i^2  a_{i+1} \dots a_j \beta_j \;\big|\; \delta_j a_{j+1} \dots a_k \delta_k^1}
%                \;&&\underbrace {\Phi_{h+1}(t_{p'+1}) \Phi_{h+1}(t_m) \Xr_{h}}
%                    _{\delta_k^2 a_{k+1} \dots a_l \delta_l}
%    \end{alignat*}

    Let $traces (\Phi_{h}(s), \Phi_{h}(t)) = \big( (\rho_0, \dots, \rho_l), (\rho'_0, \dots, \rho'_l) \big)$
    and $traces (\Phi_{h+1}(s'), \Phi_{h+1}(t')) = \big( (\sigma_h, \dots, \sigma_k), (\sigma'_h, \dots, \sigma'_k) \big)$.
    %
    We show that for frames $i$ such that $j \leq i < k$ we have
    $\rho_i = \sigma_i \wedge \rho'_i = \sigma'_i$,
    and for subsequent frames $k \leq i \leq l$ we have $\rho_i = \rho'_i$.

    \medskip

    First case: $i = j \leq k \leq l$ (the fork frame).
    Because $\Phi_{h+1}(s')$ and $\Phi_{h+1}(t')$ have nonempty common prefix $\Xl_{h+2}$,
    we have $lasht (\Phi_{h}(s) \sqcap \Phi_{h}(t)) = lasth (\Phi_{h+1}(s') \sqcap \Phi_{h+1}(t')) \geq h + 2$.
    %
    If $j < k$ then $minh (\gamma_j)$, $minh (\delta_j)$ are not affected by appending
    $\gamma^2_k$, $\delta^2_k$ and therefore $\rho_j = \sigma_j \wedge \rho'_j = \sigma'_j$.
    %
    Else if $j = k < l$ then we have $minh (\gamma^1_k) = minh (\delta^1_k) = h + 1$ and
    $minh (\gamma^2_k) = minh (\delta^2_k) \geq h + 1$, and
    therefore $\rho_j = \rho'_j = h + 1$.
    %
    Finally, if $j = l$ then $minh (\gamma_j) = minh (\delta_j) = h$ and $\rho_j = \rho'_j = h$.

    \medskip

    Second case: $j < i < k$.
    In this case the calculation of $\rho_i$, $\rho'_i$ depends on $\rho_j$, $\rho'_j$
    (for which we have shown $\rho_j = \sigma_j \wedge \rho'_j = \sigma'_j$) and
    is not affected by the appended $\gamma^2_k$, $\delta^2_k$, therefore
    $\rho_i = \sigma_i \wedge \rho'_i = \sigma'_i$.

    \medskip

    Third case: $j < i = k < l$. We have
    $minh (\gamma^1_k) = minh (\delta^1_k) = h + 1$ and
    $minh (\gamma^2_k) = minh (\delta^2_k) \geq h + 1$,
    and none of the preceding frames after the fork contain parentheses with height less than $h + 1$,
    therefore $\rho_k = \rho'_k = h + 1$.

    \medskip

    Fourth case: $k < i < l$.
    We have $\rho_i = \rho'_i = h + 1$,
    because $\rho_k = \rho'_k = h + 1$ and $minh(\gamma_i)$, $minh(\delta_i) \geq h + 1$.

    \medskip

    Fifth case: $i = l$.
    We have $\rho_l = \rho'_l = h$.

    \medskip

    So, we have shown that $\rho_i = \sigma_i \wedge \rho'_i = \sigma'_i$ for $j \leq i < k$
    and $\rho_i = \rho'_i$ for $k \leq i \leq l$.
    It trivially follows that $\Phi_{h+1}(s') \sqsubset \Phi_{h+1}(t')$ implies $\Phi_{h}(s) \sqsubset \Phi_{h}(t)$, and
    $\Phi_{h+1}(s') \sim \Phi_{h+1}(t')$ implies $\Phi_{h}(s) \sim \Phi_{h}(t)$.
    Because none of $\Phi_{h+1}(s')$, $\Phi_{h+1}(t')$ is a proper prefix of another,
    $\Phi_{h+1}(s') \subset \Phi_{h+1}(t')$ implies $\Phi_{h}(s) \subset \Phi_{h}(t)$.
    Therefore $\Phi_{h+1}(s') < \Phi_{h+1}(t')$ implies $\Phi_{h}(s) < \Phi_{h}(t)$.
    $\square$
    \end{XLem}


    Proof of theorem \ref{theorem_order_on_pe_same_as_on_pt}.
    \\[-1em]

    $\Rightarrow$. Given by lemma \ref{lemma_pe_less}.
    \\[-1em]

    $\Leftarrow$.
    We have $\Phi_{h}(s) < \Phi_{h}(t) \; \forall h$.
    Suppose that $\nexists p: s <_p t$.
    By lemma \ref{lemma_pe_order_antisymm} either $s = t$
    (in which case $\Phi_{h}(s) = \Phi_{h}(t)$, contradiction)
    or $t <_q s$ for some $q$
    (in which case $\Phi_{h}(t) < \Phi_{h}(s)$ by lemma \ref{lemma_pe_less}, contradiction).
    Therefore $\exists p: s <_p t$.
    $\square$


\end{document}

